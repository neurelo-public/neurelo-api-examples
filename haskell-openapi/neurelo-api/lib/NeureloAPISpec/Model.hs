{-
   Neurelo API Spec

   No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

   OpenAPI Version: 3.0.3
   Neurelo API Spec API version: 0
   Generated by OpenAPI Generator (https://openapi-generator.tech)
-}

{-|
Module : NeureloAPISpec.Model
-}

{-# LANGUAGE DeriveDataTypeable #-}
{-# LANGUAGE DeriveFoldable #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE TypeFamilies #-}
{-# OPTIONS_GHC -fno-warn-unused-matches -fno-warn-unused-binds -fno-warn-unused-imports #-}

module NeureloAPISpec.Model where

import NeureloAPISpec.Core
import NeureloAPISpec.MimeTypes

import Data.Aeson ((.:),(.:!),(.:?),(.=))

import qualified Control.Arrow as P (left)
import qualified Data.Aeson as A
import qualified Data.ByteString as B
import qualified Data.ByteString.Base64 as B64
import qualified Data.ByteString.Char8 as BC
import qualified Data.ByteString.Lazy as BL
import qualified Data.Data as P (Typeable, TypeRep, typeOf, typeRep)
import qualified Data.Foldable as P
import qualified Data.HashMap.Lazy as HM
import qualified Data.Map as Map
import qualified Data.Maybe as P
import qualified Data.Set as Set
import qualified Data.Text as T
import qualified Data.Text.Encoding as T
import qualified Data.Time as TI
import qualified Lens.Micro as L
import qualified Web.FormUrlEncoded as WH
import qualified Web.HttpApiData as WH

import Control.Applicative ((<|>))
import Control.Applicative (Alternative)
import Data.Function ((&))
import Data.Monoid ((<>))
import Data.Text (Text)
import Prelude (($),(/=),(.),(<$>),(<*>),(>>=),(=<<),Maybe(..),Bool(..),Char,Double,FilePath,Float,Int,Integer,String,fmap,undefined,mempty,maybe,pure,Monad,Applicative,Functor)

import qualified Prelude as P



-- * Parameter newtypes


-- ** Filter
newtype Filter = Filter { unFilter :: UserWhereInput } deriving (P.Eq, P.Show)

-- ** GroupBy
newtype GroupBy = GroupBy { unGroupBy :: [UserScalarFieldEnum] } deriving (P.Eq, P.Show)

-- ** Having
newtype Having = Having { unHaving :: UserScalarWhereWithAggregatesInput } deriving (P.Eq, P.Show)

-- ** OrderBy
newtype OrderBy = OrderBy { unOrderBy :: [UserOrderByWithRelationInput] } deriving (P.Eq, P.Show)

-- ** OrderByUserOrderByWithAggregationInput
newtype OrderByUserOrderByWithAggregationInput = OrderByUserOrderByWithAggregationInput { unOrderByUserOrderByWithAggregationInput :: [UserOrderByWithAggregationInput] } deriving (P.Eq, P.Show)

-- ** Select
newtype Select = Select { unSelect :: UserSelectInput } deriving (P.Eq, P.Show)

-- ** SelectUserAggregateInput
newtype SelectUserAggregateInput = SelectUserAggregateInput { unSelectUserAggregateInput :: UserAggregateInput } deriving (P.Eq, P.Show)

-- ** SelectUserGroupByInput
newtype SelectUserGroupByInput = SelectUserGroupByInput { unSelectUserGroupByInput :: UserGroupByInput } deriving (P.Eq, P.Show)

-- ** Skip
newtype Skip = Skip { unSkip :: Int } deriving (P.Eq, P.Show)

-- ** Take
newtype Take = Take { unTake :: Int } deriving (P.Eq, P.Show)

-- ** UserCreateManyInput2
newtype UserCreateManyInput2 = UserCreateManyInput2 { unUserCreateManyInput2 :: [UserCreateManyInput] } deriving (P.Eq, P.Show, A.ToJSON)

-- ** Value
newtype Value = Value { unValue :: Text } deriving (P.Eq, P.Show)

-- * Models


-- ** AffectedRowsOutput
-- | AffectedRowsOutput
data AffectedRowsOutput = AffectedRowsOutput
  { affectedRowsOutputCount :: !(Maybe Int) -- ^ "count"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AffectedRowsOutput
instance A.FromJSON AffectedRowsOutput where
  parseJSON = A.withObject "AffectedRowsOutput" $ \o ->
    AffectedRowsOutput
      <$> (o .:? "count")

-- | ToJSON AffectedRowsOutput
instance A.ToJSON AffectedRowsOutput where
  toJSON AffectedRowsOutput {..} =
   _omitNulls
      [ "count" .= affectedRowsOutputCount
      ]


-- | Construct a value of type 'AffectedRowsOutput' (by applying it's required fields, if any)
mkAffectedRowsOutput
  :: AffectedRowsOutput
mkAffectedRowsOutput =
  AffectedRowsOutput
  { affectedRowsOutputCount = Nothing
  }

-- ** AggregateByUser200Response
-- | AggregateByUser200Response
data AggregateByUser200Response = AggregateByUser200Response
  { aggregateByUser200ResponseData :: !(AggregateUser) -- ^ /Required/ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AggregateByUser200Response
instance A.FromJSON AggregateByUser200Response where
  parseJSON = A.withObject "AggregateByUser200Response" $ \o ->
    AggregateByUser200Response
      <$> (o .:  "data")

-- | ToJSON AggregateByUser200Response
instance A.ToJSON AggregateByUser200Response where
  toJSON AggregateByUser200Response {..} =
   _omitNulls
      [ "data" .= aggregateByUser200ResponseData
      ]


-- | Construct a value of type 'AggregateByUser200Response' (by applying it's required fields, if any)
mkAggregateByUser200Response
  :: AggregateUser -- ^ 'aggregateByUser200ResponseData' 
  -> AggregateByUser200Response
mkAggregateByUser200Response aggregateByUser200ResponseData =
  AggregateByUser200Response
  { aggregateByUser200ResponseData
  }

-- ** AggregateUser
-- | AggregateUser
data AggregateUser = AggregateUser
  { aggregateUserCount :: !(Maybe UserCountAggregateOutputType) -- ^ "_count"
  , aggregateUserMax :: !(Maybe UserMaxAggregateOutputType) -- ^ "_max"
  , aggregateUserMin :: !(Maybe UserMinAggregateOutputType) -- ^ "_min"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON AggregateUser
instance A.FromJSON AggregateUser where
  parseJSON = A.withObject "AggregateUser" $ \o ->
    AggregateUser
      <$> (o .:? "_count")
      <*> (o .:? "_max")
      <*> (o .:? "_min")

-- | ToJSON AggregateUser
instance A.ToJSON AggregateUser where
  toJSON AggregateUser {..} =
   _omitNulls
      [ "_count" .= aggregateUserCount
      , "_max" .= aggregateUserMax
      , "_min" .= aggregateUserMin
      ]


-- | Construct a value of type 'AggregateUser' (by applying it's required fields, if any)
mkAggregateUser
  :: AggregateUser
mkAggregateUser =
  AggregateUser
  { aggregateUserCount = Nothing
  , aggregateUserMax = Nothing
  , aggregateUserMin = Nothing
  }

-- ** CreateManyUser201Response
-- | CreateManyUser201Response
data CreateManyUser201Response = CreateManyUser201Response
  { createManyUser201ResponseData :: !(AffectedRowsOutput) -- ^ /Required/ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateManyUser201Response
instance A.FromJSON CreateManyUser201Response where
  parseJSON = A.withObject "CreateManyUser201Response" $ \o ->
    CreateManyUser201Response
      <$> (o .:  "data")

-- | ToJSON CreateManyUser201Response
instance A.ToJSON CreateManyUser201Response where
  toJSON CreateManyUser201Response {..} =
   _omitNulls
      [ "data" .= createManyUser201ResponseData
      ]


-- | Construct a value of type 'CreateManyUser201Response' (by applying it's required fields, if any)
mkCreateManyUser201Response
  :: AffectedRowsOutput -- ^ 'createManyUser201ResponseData' 
  -> CreateManyUser201Response
mkCreateManyUser201Response createManyUser201ResponseData =
  CreateManyUser201Response
  { createManyUser201ResponseData
  }

-- ** CreateOneUser201Response
-- | CreateOneUser201Response
data CreateOneUser201Response = CreateOneUser201Response
  { createOneUser201ResponseData :: !(User) -- ^ /Required/ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON CreateOneUser201Response
instance A.FromJSON CreateOneUser201Response where
  parseJSON = A.withObject "CreateOneUser201Response" $ \o ->
    CreateOneUser201Response
      <$> (o .:  "data")

-- | ToJSON CreateOneUser201Response
instance A.ToJSON CreateOneUser201Response where
  toJSON CreateOneUser201Response {..} =
   _omitNulls
      [ "data" .= createOneUser201ResponseData
      ]


-- | Construct a value of type 'CreateOneUser201Response' (by applying it's required fields, if any)
mkCreateOneUser201Response
  :: User -- ^ 'createOneUser201ResponseData' 
  -> CreateOneUser201Response
mkCreateOneUser201Response createOneUser201ResponseData =
  CreateOneUser201Response
  { createOneUser201ResponseData
  }

-- ** ErrorResponse
-- | ErrorResponse
data ErrorResponse = ErrorResponse
  { errorResponseDetails :: !(Maybe A.Value) -- ^ "details"
  , errorResponseError :: !(Text) -- ^ /Required/ "error"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON ErrorResponse
instance A.FromJSON ErrorResponse where
  parseJSON = A.withObject "ErrorResponse" $ \o ->
    ErrorResponse
      <$> (o .:? "details")
      <*> (o .:  "error")

-- | ToJSON ErrorResponse
instance A.ToJSON ErrorResponse where
  toJSON ErrorResponse {..} =
   _omitNulls
      [ "details" .= errorResponseDetails
      , "error" .= errorResponseError
      ]


-- | Construct a value of type 'ErrorResponse' (by applying it's required fields, if any)
mkErrorResponse
  :: Text -- ^ 'errorResponseError' 
  -> ErrorResponse
mkErrorResponse errorResponseError =
  ErrorResponse
  { errorResponseDetails = Nothing
  , errorResponseError
  }

-- ** FindUser200Response
-- | FindUser200Response
data FindUser200Response = FindUser200Response
  { findUser200ResponseData :: !([User]) -- ^ /Required/ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FindUser200Response
instance A.FromJSON FindUser200Response where
  parseJSON = A.withObject "FindUser200Response" $ \o ->
    FindUser200Response
      <$> (o .:  "data")

-- | ToJSON FindUser200Response
instance A.ToJSON FindUser200Response where
  toJSON FindUser200Response {..} =
   _omitNulls
      [ "data" .= findUser200ResponseData
      ]


-- | Construct a value of type 'FindUser200Response' (by applying it's required fields, if any)
mkFindUser200Response
  :: [User] -- ^ 'findUser200ResponseData' 
  -> FindUser200Response
mkFindUser200Response findUser200ResponseData =
  FindUser200Response
  { findUser200ResponseData
  }

-- ** FindUser400Response
-- | FindUser400Response
data FindUser400Response = FindUser400Response
  { findUser400ResponseErrors :: !([ErrorResponse]) -- ^ /Required/ "errors"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON FindUser400Response
instance A.FromJSON FindUser400Response where
  parseJSON = A.withObject "FindUser400Response" $ \o ->
    FindUser400Response
      <$> (o .:  "errors")

-- | ToJSON FindUser400Response
instance A.ToJSON FindUser400Response where
  toJSON FindUser400Response {..} =
   _omitNulls
      [ "errors" .= findUser400ResponseErrors
      ]


-- | Construct a value of type 'FindUser400Response' (by applying it's required fields, if any)
mkFindUser400Response
  :: [ErrorResponse] -- ^ 'findUser400ResponseErrors' 
  -> FindUser400Response
mkFindUser400Response findUser400ResponseErrors =
  FindUser400Response
  { findUser400ResponseErrors
  }

-- ** GroupByUser200Response
-- | GroupByUser200Response
data GroupByUser200Response = GroupByUser200Response
  { groupByUser200ResponseData :: !([UserGroupByOutputType]) -- ^ /Required/ "data"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON GroupByUser200Response
instance A.FromJSON GroupByUser200Response where
  parseJSON = A.withObject "GroupByUser200Response" $ \o ->
    GroupByUser200Response
      <$> (o .:  "data")

-- | ToJSON GroupByUser200Response
instance A.ToJSON GroupByUser200Response where
  toJSON GroupByUser200Response {..} =
   _omitNulls
      [ "data" .= groupByUser200ResponseData
      ]


-- | Construct a value of type 'GroupByUser200Response' (by applying it's required fields, if any)
mkGroupByUser200Response
  :: [UserGroupByOutputType] -- ^ 'groupByUser200ResponseData' 
  -> GroupByUser200Response
mkGroupByUser200Response groupByUser200ResponseData =
  GroupByUser200Response
  { groupByUser200ResponseData
  }

-- ** NestedIntFilter
-- | NestedIntFilter
data NestedIntFilter = NestedIntFilter
  { nestedIntFilterEq :: !(Maybe Int) -- ^ "eq"
  , nestedIntFilterEquals :: !(Maybe Int) -- ^ "equals"
  , nestedIntFilterGt :: !(Maybe Int) -- ^ "gt"
  , nestedIntFilterGte :: !(Maybe Int) -- ^ "gte"
  , nestedIntFilterIn :: !(Maybe [Int]) -- ^ "in"
  , nestedIntFilterLt :: !(Maybe Int) -- ^ "lt"
  , nestedIntFilterLte :: !(Maybe Int) -- ^ "lte"
  , nestedIntFilterNot :: !(Maybe NestedIntFilterNot) -- ^ "not"
  , nestedIntFilterNotIn :: !(Maybe [Int]) -- ^ "notIn"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NestedIntFilter
instance A.FromJSON NestedIntFilter where
  parseJSON = A.withObject "NestedIntFilter" $ \o ->
    NestedIntFilter
      <$> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "not")
      <*> (o .:? "notIn")

-- | ToJSON NestedIntFilter
instance A.ToJSON NestedIntFilter where
  toJSON NestedIntFilter {..} =
   _omitNulls
      [ "eq" .= nestedIntFilterEq
      , "equals" .= nestedIntFilterEquals
      , "gt" .= nestedIntFilterGt
      , "gte" .= nestedIntFilterGte
      , "in" .= nestedIntFilterIn
      , "lt" .= nestedIntFilterLt
      , "lte" .= nestedIntFilterLte
      , "not" .= nestedIntFilterNot
      , "notIn" .= nestedIntFilterNotIn
      ]


-- | Construct a value of type 'NestedIntFilter' (by applying it's required fields, if any)
mkNestedIntFilter
  :: NestedIntFilter
mkNestedIntFilter =
  NestedIntFilter
  { nestedIntFilterEq = Nothing
  , nestedIntFilterEquals = Nothing
  , nestedIntFilterGt = Nothing
  , nestedIntFilterGte = Nothing
  , nestedIntFilterIn = Nothing
  , nestedIntFilterLt = Nothing
  , nestedIntFilterLte = Nothing
  , nestedIntFilterNot = Nothing
  , nestedIntFilterNotIn = Nothing
  }

-- ** NestedIntFilterNot
-- | NestedIntFilterNot
data NestedIntFilterNot = NestedIntFilterNot
  { nestedIntFilterNotEq :: !(Maybe Int) -- ^ "eq"
  , nestedIntFilterNotEquals :: !(Maybe Int) -- ^ "equals"
  , nestedIntFilterNotGt :: !(Maybe Int) -- ^ "gt"
  , nestedIntFilterNotGte :: !(Maybe Int) -- ^ "gte"
  , nestedIntFilterNotIn :: !(Maybe [Int]) -- ^ "in"
  , nestedIntFilterNotLt :: !(Maybe Int) -- ^ "lt"
  , nestedIntFilterNotLte :: !(Maybe Int) -- ^ "lte"
  , nestedIntFilterNotNot :: !(Maybe NestedIntFilterNot) -- ^ "not"
  , nestedIntFilterNotNotIn :: !(Maybe [Int]) -- ^ "notIn"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NestedIntFilterNot
instance A.FromJSON NestedIntFilterNot where
  parseJSON = A.withObject "NestedIntFilterNot" $ \o ->
    NestedIntFilterNot
      <$> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "not")
      <*> (o .:? "notIn")

-- | ToJSON NestedIntFilterNot
instance A.ToJSON NestedIntFilterNot where
  toJSON NestedIntFilterNot {..} =
   _omitNulls
      [ "eq" .= nestedIntFilterNotEq
      , "equals" .= nestedIntFilterNotEquals
      , "gt" .= nestedIntFilterNotGt
      , "gte" .= nestedIntFilterNotGte
      , "in" .= nestedIntFilterNotIn
      , "lt" .= nestedIntFilterNotLt
      , "lte" .= nestedIntFilterNotLte
      , "not" .= nestedIntFilterNotNot
      , "notIn" .= nestedIntFilterNotNotIn
      ]


-- | Construct a value of type 'NestedIntFilterNot' (by applying it's required fields, if any)
mkNestedIntFilterNot
  :: NestedIntFilterNot
mkNestedIntFilterNot =
  NestedIntFilterNot
  { nestedIntFilterNotEq = Nothing
  , nestedIntFilterNotEquals = Nothing
  , nestedIntFilterNotGt = Nothing
  , nestedIntFilterNotGte = Nothing
  , nestedIntFilterNotIn = Nothing
  , nestedIntFilterNotLt = Nothing
  , nestedIntFilterNotLte = Nothing
  , nestedIntFilterNotNot = Nothing
  , nestedIntFilterNotNotIn = Nothing
  }

-- ** NestedIntNullableFilter
-- | NestedIntNullableFilter
data NestedIntNullableFilter = NestedIntNullableFilter
  { nestedIntNullableFilterEq :: !(Maybe Int) -- ^ "eq"
  , nestedIntNullableFilterEquals :: !(Maybe Int) -- ^ "equals"
  , nestedIntNullableFilterGt :: !(Maybe Int) -- ^ "gt"
  , nestedIntNullableFilterGte :: !(Maybe Int) -- ^ "gte"
  , nestedIntNullableFilterIn :: !(Maybe [Int]) -- ^ "in"
  , nestedIntNullableFilterIsSet :: !(Maybe Bool) -- ^ "isSet"
  , nestedIntNullableFilterLt :: !(Maybe Int) -- ^ "lt"
  , nestedIntNullableFilterLte :: !(Maybe Int) -- ^ "lte"
  , nestedIntNullableFilterNot :: !(Maybe NestedIntNullableFilterNot) -- ^ "not"
  , nestedIntNullableFilterNotIn :: !(Maybe [Int]) -- ^ "notIn"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NestedIntNullableFilter
instance A.FromJSON NestedIntNullableFilter where
  parseJSON = A.withObject "NestedIntNullableFilter" $ \o ->
    NestedIntNullableFilter
      <$> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "isSet")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "not")
      <*> (o .:? "notIn")

-- | ToJSON NestedIntNullableFilter
instance A.ToJSON NestedIntNullableFilter where
  toJSON NestedIntNullableFilter {..} =
   _omitNulls
      [ "eq" .= nestedIntNullableFilterEq
      , "equals" .= nestedIntNullableFilterEquals
      , "gt" .= nestedIntNullableFilterGt
      , "gte" .= nestedIntNullableFilterGte
      , "in" .= nestedIntNullableFilterIn
      , "isSet" .= nestedIntNullableFilterIsSet
      , "lt" .= nestedIntNullableFilterLt
      , "lte" .= nestedIntNullableFilterLte
      , "not" .= nestedIntNullableFilterNot
      , "notIn" .= nestedIntNullableFilterNotIn
      ]


-- | Construct a value of type 'NestedIntNullableFilter' (by applying it's required fields, if any)
mkNestedIntNullableFilter
  :: NestedIntNullableFilter
mkNestedIntNullableFilter =
  NestedIntNullableFilter
  { nestedIntNullableFilterEq = Nothing
  , nestedIntNullableFilterEquals = Nothing
  , nestedIntNullableFilterGt = Nothing
  , nestedIntNullableFilterGte = Nothing
  , nestedIntNullableFilterIn = Nothing
  , nestedIntNullableFilterIsSet = Nothing
  , nestedIntNullableFilterLt = Nothing
  , nestedIntNullableFilterLte = Nothing
  , nestedIntNullableFilterNot = Nothing
  , nestedIntNullableFilterNotIn = Nothing
  }

-- ** NestedIntNullableFilterNot
-- | NestedIntNullableFilterNot
data NestedIntNullableFilterNot = NestedIntNullableFilterNot
  { nestedIntNullableFilterNotEq :: !(Maybe Int) -- ^ "eq"
  , nestedIntNullableFilterNotEquals :: !(Maybe Int) -- ^ "equals"
  , nestedIntNullableFilterNotGt :: !(Maybe Int) -- ^ "gt"
  , nestedIntNullableFilterNotGte :: !(Maybe Int) -- ^ "gte"
  , nestedIntNullableFilterNotIn :: !(Maybe [Int]) -- ^ "in"
  , nestedIntNullableFilterNotIsSet :: !(Maybe Bool) -- ^ "isSet"
  , nestedIntNullableFilterNotLt :: !(Maybe Int) -- ^ "lt"
  , nestedIntNullableFilterNotLte :: !(Maybe Int) -- ^ "lte"
  , nestedIntNullableFilterNotNot :: !(Maybe NestedIntNullableFilterNot) -- ^ "not"
  , nestedIntNullableFilterNotNotIn :: !(Maybe [Int]) -- ^ "notIn"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NestedIntNullableFilterNot
instance A.FromJSON NestedIntNullableFilterNot where
  parseJSON = A.withObject "NestedIntNullableFilterNot" $ \o ->
    NestedIntNullableFilterNot
      <$> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "isSet")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "not")
      <*> (o .:? "notIn")

-- | ToJSON NestedIntNullableFilterNot
instance A.ToJSON NestedIntNullableFilterNot where
  toJSON NestedIntNullableFilterNot {..} =
   _omitNulls
      [ "eq" .= nestedIntNullableFilterNotEq
      , "equals" .= nestedIntNullableFilterNotEquals
      , "gt" .= nestedIntNullableFilterNotGt
      , "gte" .= nestedIntNullableFilterNotGte
      , "in" .= nestedIntNullableFilterNotIn
      , "isSet" .= nestedIntNullableFilterNotIsSet
      , "lt" .= nestedIntNullableFilterNotLt
      , "lte" .= nestedIntNullableFilterNotLte
      , "not" .= nestedIntNullableFilterNotNot
      , "notIn" .= nestedIntNullableFilterNotNotIn
      ]


-- | Construct a value of type 'NestedIntNullableFilterNot' (by applying it's required fields, if any)
mkNestedIntNullableFilterNot
  :: NestedIntNullableFilterNot
mkNestedIntNullableFilterNot =
  NestedIntNullableFilterNot
  { nestedIntNullableFilterNotEq = Nothing
  , nestedIntNullableFilterNotEquals = Nothing
  , nestedIntNullableFilterNotGt = Nothing
  , nestedIntNullableFilterNotGte = Nothing
  , nestedIntNullableFilterNotIn = Nothing
  , nestedIntNullableFilterNotIsSet = Nothing
  , nestedIntNullableFilterNotLt = Nothing
  , nestedIntNullableFilterNotLte = Nothing
  , nestedIntNullableFilterNotNot = Nothing
  , nestedIntNullableFilterNotNotIn = Nothing
  }

-- ** NestedStringFilter
-- | NestedStringFilter
data NestedStringFilter = NestedStringFilter
  { nestedStringFilterContains :: !(Maybe Text) -- ^ "contains"
  , nestedStringFilterEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , nestedStringFilterEq :: !(Maybe Text) -- ^ "eq"
  , nestedStringFilterEquals :: !(Maybe Text) -- ^ "equals"
  , nestedStringFilterGt :: !(Maybe Text) -- ^ "gt"
  , nestedStringFilterGte :: !(Maybe Text) -- ^ "gte"
  , nestedStringFilterIn :: !(Maybe [Text]) -- ^ "in"
  , nestedStringFilterLt :: !(Maybe Text) -- ^ "lt"
  , nestedStringFilterLte :: !(Maybe Text) -- ^ "lte"
  , nestedStringFilterNot :: !(Maybe NestedStringFilterNot) -- ^ "not"
  , nestedStringFilterNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , nestedStringFilterStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NestedStringFilter
instance A.FromJSON NestedStringFilter where
  parseJSON = A.withObject "NestedStringFilter" $ \o ->
    NestedStringFilter
      <$> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON NestedStringFilter
instance A.ToJSON NestedStringFilter where
  toJSON NestedStringFilter {..} =
   _omitNulls
      [ "contains" .= nestedStringFilterContains
      , "endsWith" .= nestedStringFilterEndsWith
      , "eq" .= nestedStringFilterEq
      , "equals" .= nestedStringFilterEquals
      , "gt" .= nestedStringFilterGt
      , "gte" .= nestedStringFilterGte
      , "in" .= nestedStringFilterIn
      , "lt" .= nestedStringFilterLt
      , "lte" .= nestedStringFilterLte
      , "not" .= nestedStringFilterNot
      , "notIn" .= nestedStringFilterNotIn
      , "startsWith" .= nestedStringFilterStartsWith
      ]


-- | Construct a value of type 'NestedStringFilter' (by applying it's required fields, if any)
mkNestedStringFilter
  :: NestedStringFilter
mkNestedStringFilter =
  NestedStringFilter
  { nestedStringFilterContains = Nothing
  , nestedStringFilterEndsWith = Nothing
  , nestedStringFilterEq = Nothing
  , nestedStringFilterEquals = Nothing
  , nestedStringFilterGt = Nothing
  , nestedStringFilterGte = Nothing
  , nestedStringFilterIn = Nothing
  , nestedStringFilterLt = Nothing
  , nestedStringFilterLte = Nothing
  , nestedStringFilterNot = Nothing
  , nestedStringFilterNotIn = Nothing
  , nestedStringFilterStartsWith = Nothing
  }

-- ** NestedStringFilterNot
-- | NestedStringFilterNot
data NestedStringFilterNot = NestedStringFilterNot
  { nestedStringFilterNotContains :: !(Maybe Text) -- ^ "contains"
  , nestedStringFilterNotEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , nestedStringFilterNotEq :: !(Maybe Text) -- ^ "eq"
  , nestedStringFilterNotEquals :: !(Maybe Text) -- ^ "equals"
  , nestedStringFilterNotGt :: !(Maybe Text) -- ^ "gt"
  , nestedStringFilterNotGte :: !(Maybe Text) -- ^ "gte"
  , nestedStringFilterNotIn :: !(Maybe [Text]) -- ^ "in"
  , nestedStringFilterNotLt :: !(Maybe Text) -- ^ "lt"
  , nestedStringFilterNotLte :: !(Maybe Text) -- ^ "lte"
  , nestedStringFilterNotNot :: !(Maybe NestedStringFilterNot) -- ^ "not"
  , nestedStringFilterNotNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , nestedStringFilterNotStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NestedStringFilterNot
instance A.FromJSON NestedStringFilterNot where
  parseJSON = A.withObject "NestedStringFilterNot" $ \o ->
    NestedStringFilterNot
      <$> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON NestedStringFilterNot
instance A.ToJSON NestedStringFilterNot where
  toJSON NestedStringFilterNot {..} =
   _omitNulls
      [ "contains" .= nestedStringFilterNotContains
      , "endsWith" .= nestedStringFilterNotEndsWith
      , "eq" .= nestedStringFilterNotEq
      , "equals" .= nestedStringFilterNotEquals
      , "gt" .= nestedStringFilterNotGt
      , "gte" .= nestedStringFilterNotGte
      , "in" .= nestedStringFilterNotIn
      , "lt" .= nestedStringFilterNotLt
      , "lte" .= nestedStringFilterNotLte
      , "not" .= nestedStringFilterNotNot
      , "notIn" .= nestedStringFilterNotNotIn
      , "startsWith" .= nestedStringFilterNotStartsWith
      ]


-- | Construct a value of type 'NestedStringFilterNot' (by applying it's required fields, if any)
mkNestedStringFilterNot
  :: NestedStringFilterNot
mkNestedStringFilterNot =
  NestedStringFilterNot
  { nestedStringFilterNotContains = Nothing
  , nestedStringFilterNotEndsWith = Nothing
  , nestedStringFilterNotEq = Nothing
  , nestedStringFilterNotEquals = Nothing
  , nestedStringFilterNotGt = Nothing
  , nestedStringFilterNotGte = Nothing
  , nestedStringFilterNotIn = Nothing
  , nestedStringFilterNotLt = Nothing
  , nestedStringFilterNotLte = Nothing
  , nestedStringFilterNotNot = Nothing
  , nestedStringFilterNotNotIn = Nothing
  , nestedStringFilterNotStartsWith = Nothing
  }

-- ** NestedStringNullableFilter
-- | NestedStringNullableFilter
data NestedStringNullableFilter = NestedStringNullableFilter
  { nestedStringNullableFilterContains :: !(Maybe Text) -- ^ "contains"
  , nestedStringNullableFilterEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , nestedStringNullableFilterEq :: !(Maybe Text) -- ^ "eq"
  , nestedStringNullableFilterEquals :: !(Maybe Text) -- ^ "equals"
  , nestedStringNullableFilterGt :: !(Maybe Text) -- ^ "gt"
  , nestedStringNullableFilterGte :: !(Maybe Text) -- ^ "gte"
  , nestedStringNullableFilterIn :: !(Maybe [Text]) -- ^ "in"
  , nestedStringNullableFilterIsSet :: !(Maybe Bool) -- ^ "isSet"
  , nestedStringNullableFilterLt :: !(Maybe Text) -- ^ "lt"
  , nestedStringNullableFilterLte :: !(Maybe Text) -- ^ "lte"
  , nestedStringNullableFilterNot :: !(Maybe NestedStringNullableFilterNot) -- ^ "not"
  , nestedStringNullableFilterNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , nestedStringNullableFilterStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NestedStringNullableFilter
instance A.FromJSON NestedStringNullableFilter where
  parseJSON = A.withObject "NestedStringNullableFilter" $ \o ->
    NestedStringNullableFilter
      <$> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "isSet")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON NestedStringNullableFilter
instance A.ToJSON NestedStringNullableFilter where
  toJSON NestedStringNullableFilter {..} =
   _omitNulls
      [ "contains" .= nestedStringNullableFilterContains
      , "endsWith" .= nestedStringNullableFilterEndsWith
      , "eq" .= nestedStringNullableFilterEq
      , "equals" .= nestedStringNullableFilterEquals
      , "gt" .= nestedStringNullableFilterGt
      , "gte" .= nestedStringNullableFilterGte
      , "in" .= nestedStringNullableFilterIn
      , "isSet" .= nestedStringNullableFilterIsSet
      , "lt" .= nestedStringNullableFilterLt
      , "lte" .= nestedStringNullableFilterLte
      , "not" .= nestedStringNullableFilterNot
      , "notIn" .= nestedStringNullableFilterNotIn
      , "startsWith" .= nestedStringNullableFilterStartsWith
      ]


-- | Construct a value of type 'NestedStringNullableFilter' (by applying it's required fields, if any)
mkNestedStringNullableFilter
  :: NestedStringNullableFilter
mkNestedStringNullableFilter =
  NestedStringNullableFilter
  { nestedStringNullableFilterContains = Nothing
  , nestedStringNullableFilterEndsWith = Nothing
  , nestedStringNullableFilterEq = Nothing
  , nestedStringNullableFilterEquals = Nothing
  , nestedStringNullableFilterGt = Nothing
  , nestedStringNullableFilterGte = Nothing
  , nestedStringNullableFilterIn = Nothing
  , nestedStringNullableFilterIsSet = Nothing
  , nestedStringNullableFilterLt = Nothing
  , nestedStringNullableFilterLte = Nothing
  , nestedStringNullableFilterNot = Nothing
  , nestedStringNullableFilterNotIn = Nothing
  , nestedStringNullableFilterStartsWith = Nothing
  }

-- ** NestedStringNullableFilterNot
-- | NestedStringNullableFilterNot
data NestedStringNullableFilterNot = NestedStringNullableFilterNot
  { nestedStringNullableFilterNotContains :: !(Maybe Text) -- ^ "contains"
  , nestedStringNullableFilterNotEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , nestedStringNullableFilterNotEq :: !(Maybe Text) -- ^ "eq"
  , nestedStringNullableFilterNotEquals :: !(Maybe Text) -- ^ "equals"
  , nestedStringNullableFilterNotGt :: !(Maybe Text) -- ^ "gt"
  , nestedStringNullableFilterNotGte :: !(Maybe Text) -- ^ "gte"
  , nestedStringNullableFilterNotIn :: !(Maybe [Text]) -- ^ "in"
  , nestedStringNullableFilterNotIsSet :: !(Maybe Bool) -- ^ "isSet"
  , nestedStringNullableFilterNotLt :: !(Maybe Text) -- ^ "lt"
  , nestedStringNullableFilterNotLte :: !(Maybe Text) -- ^ "lte"
  , nestedStringNullableFilterNotNot :: !(Maybe NestedStringNullableFilterNot) -- ^ "not"
  , nestedStringNullableFilterNotNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , nestedStringNullableFilterNotStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NestedStringNullableFilterNot
instance A.FromJSON NestedStringNullableFilterNot where
  parseJSON = A.withObject "NestedStringNullableFilterNot" $ \o ->
    NestedStringNullableFilterNot
      <$> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "isSet")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON NestedStringNullableFilterNot
instance A.ToJSON NestedStringNullableFilterNot where
  toJSON NestedStringNullableFilterNot {..} =
   _omitNulls
      [ "contains" .= nestedStringNullableFilterNotContains
      , "endsWith" .= nestedStringNullableFilterNotEndsWith
      , "eq" .= nestedStringNullableFilterNotEq
      , "equals" .= nestedStringNullableFilterNotEquals
      , "gt" .= nestedStringNullableFilterNotGt
      , "gte" .= nestedStringNullableFilterNotGte
      , "in" .= nestedStringNullableFilterNotIn
      , "isSet" .= nestedStringNullableFilterNotIsSet
      , "lt" .= nestedStringNullableFilterNotLt
      , "lte" .= nestedStringNullableFilterNotLte
      , "not" .= nestedStringNullableFilterNotNot
      , "notIn" .= nestedStringNullableFilterNotNotIn
      , "startsWith" .= nestedStringNullableFilterNotStartsWith
      ]


-- | Construct a value of type 'NestedStringNullableFilterNot' (by applying it's required fields, if any)
mkNestedStringNullableFilterNot
  :: NestedStringNullableFilterNot
mkNestedStringNullableFilterNot =
  NestedStringNullableFilterNot
  { nestedStringNullableFilterNotContains = Nothing
  , nestedStringNullableFilterNotEndsWith = Nothing
  , nestedStringNullableFilterNotEq = Nothing
  , nestedStringNullableFilterNotEquals = Nothing
  , nestedStringNullableFilterNotGt = Nothing
  , nestedStringNullableFilterNotGte = Nothing
  , nestedStringNullableFilterNotIn = Nothing
  , nestedStringNullableFilterNotIsSet = Nothing
  , nestedStringNullableFilterNotLt = Nothing
  , nestedStringNullableFilterNotLte = Nothing
  , nestedStringNullableFilterNotNot = Nothing
  , nestedStringNullableFilterNotNotIn = Nothing
  , nestedStringNullableFilterNotStartsWith = Nothing
  }

-- ** NestedStringNullableWithAggregatesFilter
-- | NestedStringNullableWithAggregatesFilter
data NestedStringNullableWithAggregatesFilter = NestedStringNullableWithAggregatesFilter
  { nestedStringNullableWithAggregatesFilterCount :: !(Maybe NestedIntNullableFilter) -- ^ "_count"
  , nestedStringNullableWithAggregatesFilterMax :: !(Maybe NestedStringNullableFilter) -- ^ "_max"
  , nestedStringNullableWithAggregatesFilterMin :: !(Maybe NestedStringNullableFilter) -- ^ "_min"
  , nestedStringNullableWithAggregatesFilterContains :: !(Maybe Text) -- ^ "contains"
  , nestedStringNullableWithAggregatesFilterEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , nestedStringNullableWithAggregatesFilterEq :: !(Maybe Text) -- ^ "eq"
  , nestedStringNullableWithAggregatesFilterEquals :: !(Maybe Text) -- ^ "equals"
  , nestedStringNullableWithAggregatesFilterGt :: !(Maybe Text) -- ^ "gt"
  , nestedStringNullableWithAggregatesFilterGte :: !(Maybe Text) -- ^ "gte"
  , nestedStringNullableWithAggregatesFilterIn :: !(Maybe [Text]) -- ^ "in"
  , nestedStringNullableWithAggregatesFilterIsSet :: !(Maybe Bool) -- ^ "isSet"
  , nestedStringNullableWithAggregatesFilterLt :: !(Maybe Text) -- ^ "lt"
  , nestedStringNullableWithAggregatesFilterLte :: !(Maybe Text) -- ^ "lte"
  , nestedStringNullableWithAggregatesFilterNot :: !(Maybe NestedStringNullableWithAggregatesFilterNot) -- ^ "not"
  , nestedStringNullableWithAggregatesFilterNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , nestedStringNullableWithAggregatesFilterStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NestedStringNullableWithAggregatesFilter
instance A.FromJSON NestedStringNullableWithAggregatesFilter where
  parseJSON = A.withObject "NestedStringNullableWithAggregatesFilter" $ \o ->
    NestedStringNullableWithAggregatesFilter
      <$> (o .:? "_count")
      <*> (o .:? "_max")
      <*> (o .:? "_min")
      <*> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "isSet")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON NestedStringNullableWithAggregatesFilter
instance A.ToJSON NestedStringNullableWithAggregatesFilter where
  toJSON NestedStringNullableWithAggregatesFilter {..} =
   _omitNulls
      [ "_count" .= nestedStringNullableWithAggregatesFilterCount
      , "_max" .= nestedStringNullableWithAggregatesFilterMax
      , "_min" .= nestedStringNullableWithAggregatesFilterMin
      , "contains" .= nestedStringNullableWithAggregatesFilterContains
      , "endsWith" .= nestedStringNullableWithAggregatesFilterEndsWith
      , "eq" .= nestedStringNullableWithAggregatesFilterEq
      , "equals" .= nestedStringNullableWithAggregatesFilterEquals
      , "gt" .= nestedStringNullableWithAggregatesFilterGt
      , "gte" .= nestedStringNullableWithAggregatesFilterGte
      , "in" .= nestedStringNullableWithAggregatesFilterIn
      , "isSet" .= nestedStringNullableWithAggregatesFilterIsSet
      , "lt" .= nestedStringNullableWithAggregatesFilterLt
      , "lte" .= nestedStringNullableWithAggregatesFilterLte
      , "not" .= nestedStringNullableWithAggregatesFilterNot
      , "notIn" .= nestedStringNullableWithAggregatesFilterNotIn
      , "startsWith" .= nestedStringNullableWithAggregatesFilterStartsWith
      ]


-- | Construct a value of type 'NestedStringNullableWithAggregatesFilter' (by applying it's required fields, if any)
mkNestedStringNullableWithAggregatesFilter
  :: NestedStringNullableWithAggregatesFilter
mkNestedStringNullableWithAggregatesFilter =
  NestedStringNullableWithAggregatesFilter
  { nestedStringNullableWithAggregatesFilterCount = Nothing
  , nestedStringNullableWithAggregatesFilterMax = Nothing
  , nestedStringNullableWithAggregatesFilterMin = Nothing
  , nestedStringNullableWithAggregatesFilterContains = Nothing
  , nestedStringNullableWithAggregatesFilterEndsWith = Nothing
  , nestedStringNullableWithAggregatesFilterEq = Nothing
  , nestedStringNullableWithAggregatesFilterEquals = Nothing
  , nestedStringNullableWithAggregatesFilterGt = Nothing
  , nestedStringNullableWithAggregatesFilterGte = Nothing
  , nestedStringNullableWithAggregatesFilterIn = Nothing
  , nestedStringNullableWithAggregatesFilterIsSet = Nothing
  , nestedStringNullableWithAggregatesFilterLt = Nothing
  , nestedStringNullableWithAggregatesFilterLte = Nothing
  , nestedStringNullableWithAggregatesFilterNot = Nothing
  , nestedStringNullableWithAggregatesFilterNotIn = Nothing
  , nestedStringNullableWithAggregatesFilterStartsWith = Nothing
  }

-- ** NestedStringNullableWithAggregatesFilterNot
-- | NestedStringNullableWithAggregatesFilterNot
data NestedStringNullableWithAggregatesFilterNot = NestedStringNullableWithAggregatesFilterNot
  { nestedStringNullableWithAggregatesFilterNotCount :: !(Maybe NestedIntNullableFilter) -- ^ "_count"
  , nestedStringNullableWithAggregatesFilterNotMax :: !(Maybe NestedStringNullableFilter) -- ^ "_max"
  , nestedStringNullableWithAggregatesFilterNotMin :: !(Maybe NestedStringNullableFilter) -- ^ "_min"
  , nestedStringNullableWithAggregatesFilterNotContains :: !(Maybe Text) -- ^ "contains"
  , nestedStringNullableWithAggregatesFilterNotEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , nestedStringNullableWithAggregatesFilterNotEq :: !(Maybe Text) -- ^ "eq"
  , nestedStringNullableWithAggregatesFilterNotEquals :: !(Maybe Text) -- ^ "equals"
  , nestedStringNullableWithAggregatesFilterNotGt :: !(Maybe Text) -- ^ "gt"
  , nestedStringNullableWithAggregatesFilterNotGte :: !(Maybe Text) -- ^ "gte"
  , nestedStringNullableWithAggregatesFilterNotIn :: !(Maybe [Text]) -- ^ "in"
  , nestedStringNullableWithAggregatesFilterNotIsSet :: !(Maybe Bool) -- ^ "isSet"
  , nestedStringNullableWithAggregatesFilterNotLt :: !(Maybe Text) -- ^ "lt"
  , nestedStringNullableWithAggregatesFilterNotLte :: !(Maybe Text) -- ^ "lte"
  , nestedStringNullableWithAggregatesFilterNotNot :: !(Maybe NestedStringNullableWithAggregatesFilterNot) -- ^ "not"
  , nestedStringNullableWithAggregatesFilterNotNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , nestedStringNullableWithAggregatesFilterNotStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NestedStringNullableWithAggregatesFilterNot
instance A.FromJSON NestedStringNullableWithAggregatesFilterNot where
  parseJSON = A.withObject "NestedStringNullableWithAggregatesFilterNot" $ \o ->
    NestedStringNullableWithAggregatesFilterNot
      <$> (o .:? "_count")
      <*> (o .:? "_max")
      <*> (o .:? "_min")
      <*> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "isSet")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON NestedStringNullableWithAggregatesFilterNot
instance A.ToJSON NestedStringNullableWithAggregatesFilterNot where
  toJSON NestedStringNullableWithAggregatesFilterNot {..} =
   _omitNulls
      [ "_count" .= nestedStringNullableWithAggregatesFilterNotCount
      , "_max" .= nestedStringNullableWithAggregatesFilterNotMax
      , "_min" .= nestedStringNullableWithAggregatesFilterNotMin
      , "contains" .= nestedStringNullableWithAggregatesFilterNotContains
      , "endsWith" .= nestedStringNullableWithAggregatesFilterNotEndsWith
      , "eq" .= nestedStringNullableWithAggregatesFilterNotEq
      , "equals" .= nestedStringNullableWithAggregatesFilterNotEquals
      , "gt" .= nestedStringNullableWithAggregatesFilterNotGt
      , "gte" .= nestedStringNullableWithAggregatesFilterNotGte
      , "in" .= nestedStringNullableWithAggregatesFilterNotIn
      , "isSet" .= nestedStringNullableWithAggregatesFilterNotIsSet
      , "lt" .= nestedStringNullableWithAggregatesFilterNotLt
      , "lte" .= nestedStringNullableWithAggregatesFilterNotLte
      , "not" .= nestedStringNullableWithAggregatesFilterNotNot
      , "notIn" .= nestedStringNullableWithAggregatesFilterNotNotIn
      , "startsWith" .= nestedStringNullableWithAggregatesFilterNotStartsWith
      ]


-- | Construct a value of type 'NestedStringNullableWithAggregatesFilterNot' (by applying it's required fields, if any)
mkNestedStringNullableWithAggregatesFilterNot
  :: NestedStringNullableWithAggregatesFilterNot
mkNestedStringNullableWithAggregatesFilterNot =
  NestedStringNullableWithAggregatesFilterNot
  { nestedStringNullableWithAggregatesFilterNotCount = Nothing
  , nestedStringNullableWithAggregatesFilterNotMax = Nothing
  , nestedStringNullableWithAggregatesFilterNotMin = Nothing
  , nestedStringNullableWithAggregatesFilterNotContains = Nothing
  , nestedStringNullableWithAggregatesFilterNotEndsWith = Nothing
  , nestedStringNullableWithAggregatesFilterNotEq = Nothing
  , nestedStringNullableWithAggregatesFilterNotEquals = Nothing
  , nestedStringNullableWithAggregatesFilterNotGt = Nothing
  , nestedStringNullableWithAggregatesFilterNotGte = Nothing
  , nestedStringNullableWithAggregatesFilterNotIn = Nothing
  , nestedStringNullableWithAggregatesFilterNotIsSet = Nothing
  , nestedStringNullableWithAggregatesFilterNotLt = Nothing
  , nestedStringNullableWithAggregatesFilterNotLte = Nothing
  , nestedStringNullableWithAggregatesFilterNotNot = Nothing
  , nestedStringNullableWithAggregatesFilterNotNotIn = Nothing
  , nestedStringNullableWithAggregatesFilterNotStartsWith = Nothing
  }

-- ** NestedStringWithAggregatesFilter
-- | NestedStringWithAggregatesFilter
data NestedStringWithAggregatesFilter = NestedStringWithAggregatesFilter
  { nestedStringWithAggregatesFilterCount :: !(Maybe NestedIntFilter) -- ^ "_count"
  , nestedStringWithAggregatesFilterMax :: !(Maybe NestedStringFilter) -- ^ "_max"
  , nestedStringWithAggregatesFilterMin :: !(Maybe NestedStringFilter) -- ^ "_min"
  , nestedStringWithAggregatesFilterContains :: !(Maybe Text) -- ^ "contains"
  , nestedStringWithAggregatesFilterEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , nestedStringWithAggregatesFilterEq :: !(Maybe Text) -- ^ "eq"
  , nestedStringWithAggregatesFilterEquals :: !(Maybe Text) -- ^ "equals"
  , nestedStringWithAggregatesFilterGt :: !(Maybe Text) -- ^ "gt"
  , nestedStringWithAggregatesFilterGte :: !(Maybe Text) -- ^ "gte"
  , nestedStringWithAggregatesFilterIn :: !(Maybe [Text]) -- ^ "in"
  , nestedStringWithAggregatesFilterLt :: !(Maybe Text) -- ^ "lt"
  , nestedStringWithAggregatesFilterLte :: !(Maybe Text) -- ^ "lte"
  , nestedStringWithAggregatesFilterNot :: !(Maybe NestedStringWithAggregatesFilterNot) -- ^ "not"
  , nestedStringWithAggregatesFilterNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , nestedStringWithAggregatesFilterStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NestedStringWithAggregatesFilter
instance A.FromJSON NestedStringWithAggregatesFilter where
  parseJSON = A.withObject "NestedStringWithAggregatesFilter" $ \o ->
    NestedStringWithAggregatesFilter
      <$> (o .:? "_count")
      <*> (o .:? "_max")
      <*> (o .:? "_min")
      <*> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON NestedStringWithAggregatesFilter
instance A.ToJSON NestedStringWithAggregatesFilter where
  toJSON NestedStringWithAggregatesFilter {..} =
   _omitNulls
      [ "_count" .= nestedStringWithAggregatesFilterCount
      , "_max" .= nestedStringWithAggregatesFilterMax
      , "_min" .= nestedStringWithAggregatesFilterMin
      , "contains" .= nestedStringWithAggregatesFilterContains
      , "endsWith" .= nestedStringWithAggregatesFilterEndsWith
      , "eq" .= nestedStringWithAggregatesFilterEq
      , "equals" .= nestedStringWithAggregatesFilterEquals
      , "gt" .= nestedStringWithAggregatesFilterGt
      , "gte" .= nestedStringWithAggregatesFilterGte
      , "in" .= nestedStringWithAggregatesFilterIn
      , "lt" .= nestedStringWithAggregatesFilterLt
      , "lte" .= nestedStringWithAggregatesFilterLte
      , "not" .= nestedStringWithAggregatesFilterNot
      , "notIn" .= nestedStringWithAggregatesFilterNotIn
      , "startsWith" .= nestedStringWithAggregatesFilterStartsWith
      ]


-- | Construct a value of type 'NestedStringWithAggregatesFilter' (by applying it's required fields, if any)
mkNestedStringWithAggregatesFilter
  :: NestedStringWithAggregatesFilter
mkNestedStringWithAggregatesFilter =
  NestedStringWithAggregatesFilter
  { nestedStringWithAggregatesFilterCount = Nothing
  , nestedStringWithAggregatesFilterMax = Nothing
  , nestedStringWithAggregatesFilterMin = Nothing
  , nestedStringWithAggregatesFilterContains = Nothing
  , nestedStringWithAggregatesFilterEndsWith = Nothing
  , nestedStringWithAggregatesFilterEq = Nothing
  , nestedStringWithAggregatesFilterEquals = Nothing
  , nestedStringWithAggregatesFilterGt = Nothing
  , nestedStringWithAggregatesFilterGte = Nothing
  , nestedStringWithAggregatesFilterIn = Nothing
  , nestedStringWithAggregatesFilterLt = Nothing
  , nestedStringWithAggregatesFilterLte = Nothing
  , nestedStringWithAggregatesFilterNot = Nothing
  , nestedStringWithAggregatesFilterNotIn = Nothing
  , nestedStringWithAggregatesFilterStartsWith = Nothing
  }

-- ** NestedStringWithAggregatesFilterNot
-- | NestedStringWithAggregatesFilterNot
data NestedStringWithAggregatesFilterNot = NestedStringWithAggregatesFilterNot
  { nestedStringWithAggregatesFilterNotCount :: !(Maybe NestedIntFilter) -- ^ "_count"
  , nestedStringWithAggregatesFilterNotMax :: !(Maybe NestedStringFilter) -- ^ "_max"
  , nestedStringWithAggregatesFilterNotMin :: !(Maybe NestedStringFilter) -- ^ "_min"
  , nestedStringWithAggregatesFilterNotContains :: !(Maybe Text) -- ^ "contains"
  , nestedStringWithAggregatesFilterNotEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , nestedStringWithAggregatesFilterNotEq :: !(Maybe Text) -- ^ "eq"
  , nestedStringWithAggregatesFilterNotEquals :: !(Maybe Text) -- ^ "equals"
  , nestedStringWithAggregatesFilterNotGt :: !(Maybe Text) -- ^ "gt"
  , nestedStringWithAggregatesFilterNotGte :: !(Maybe Text) -- ^ "gte"
  , nestedStringWithAggregatesFilterNotIn :: !(Maybe [Text]) -- ^ "in"
  , nestedStringWithAggregatesFilterNotLt :: !(Maybe Text) -- ^ "lt"
  , nestedStringWithAggregatesFilterNotLte :: !(Maybe Text) -- ^ "lte"
  , nestedStringWithAggregatesFilterNotNot :: !(Maybe NestedStringWithAggregatesFilterNot) -- ^ "not"
  , nestedStringWithAggregatesFilterNotNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , nestedStringWithAggregatesFilterNotStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NestedStringWithAggregatesFilterNot
instance A.FromJSON NestedStringWithAggregatesFilterNot where
  parseJSON = A.withObject "NestedStringWithAggregatesFilterNot" $ \o ->
    NestedStringWithAggregatesFilterNot
      <$> (o .:? "_count")
      <*> (o .:? "_max")
      <*> (o .:? "_min")
      <*> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON NestedStringWithAggregatesFilterNot
instance A.ToJSON NestedStringWithAggregatesFilterNot where
  toJSON NestedStringWithAggregatesFilterNot {..} =
   _omitNulls
      [ "_count" .= nestedStringWithAggregatesFilterNotCount
      , "_max" .= nestedStringWithAggregatesFilterNotMax
      , "_min" .= nestedStringWithAggregatesFilterNotMin
      , "contains" .= nestedStringWithAggregatesFilterNotContains
      , "endsWith" .= nestedStringWithAggregatesFilterNotEndsWith
      , "eq" .= nestedStringWithAggregatesFilterNotEq
      , "equals" .= nestedStringWithAggregatesFilterNotEquals
      , "gt" .= nestedStringWithAggregatesFilterNotGt
      , "gte" .= nestedStringWithAggregatesFilterNotGte
      , "in" .= nestedStringWithAggregatesFilterNotIn
      , "lt" .= nestedStringWithAggregatesFilterNotLt
      , "lte" .= nestedStringWithAggregatesFilterNotLte
      , "not" .= nestedStringWithAggregatesFilterNotNot
      , "notIn" .= nestedStringWithAggregatesFilterNotNotIn
      , "startsWith" .= nestedStringWithAggregatesFilterNotStartsWith
      ]


-- | Construct a value of type 'NestedStringWithAggregatesFilterNot' (by applying it's required fields, if any)
mkNestedStringWithAggregatesFilterNot
  :: NestedStringWithAggregatesFilterNot
mkNestedStringWithAggregatesFilterNot =
  NestedStringWithAggregatesFilterNot
  { nestedStringWithAggregatesFilterNotCount = Nothing
  , nestedStringWithAggregatesFilterNotMax = Nothing
  , nestedStringWithAggregatesFilterNotMin = Nothing
  , nestedStringWithAggregatesFilterNotContains = Nothing
  , nestedStringWithAggregatesFilterNotEndsWith = Nothing
  , nestedStringWithAggregatesFilterNotEq = Nothing
  , nestedStringWithAggregatesFilterNotEquals = Nothing
  , nestedStringWithAggregatesFilterNotGt = Nothing
  , nestedStringWithAggregatesFilterNotGte = Nothing
  , nestedStringWithAggregatesFilterNotIn = Nothing
  , nestedStringWithAggregatesFilterNotLt = Nothing
  , nestedStringWithAggregatesFilterNotLte = Nothing
  , nestedStringWithAggregatesFilterNotNot = Nothing
  , nestedStringWithAggregatesFilterNotNotIn = Nothing
  , nestedStringWithAggregatesFilterNotStartsWith = Nothing
  }

-- ** NullableStringFieldUpdateOperationsInput
-- | NullableStringFieldUpdateOperationsInput
data NullableStringFieldUpdateOperationsInput = NullableStringFieldUpdateOperationsInput
  { nullableStringFieldUpdateOperationsInputSet :: !(Maybe Text) -- ^ "set"
  , nullableStringFieldUpdateOperationsInputUnset :: !(Maybe Bool) -- ^ "unset"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON NullableStringFieldUpdateOperationsInput
instance A.FromJSON NullableStringFieldUpdateOperationsInput where
  parseJSON = A.withObject "NullableStringFieldUpdateOperationsInput" $ \o ->
    NullableStringFieldUpdateOperationsInput
      <$> (o .:? "set")
      <*> (o .:? "unset")

-- | ToJSON NullableStringFieldUpdateOperationsInput
instance A.ToJSON NullableStringFieldUpdateOperationsInput where
  toJSON NullableStringFieldUpdateOperationsInput {..} =
   _omitNulls
      [ "set" .= nullableStringFieldUpdateOperationsInputSet
      , "unset" .= nullableStringFieldUpdateOperationsInputUnset
      ]


-- | Construct a value of type 'NullableStringFieldUpdateOperationsInput' (by applying it's required fields, if any)
mkNullableStringFieldUpdateOperationsInput
  :: NullableStringFieldUpdateOperationsInput
mkNullableStringFieldUpdateOperationsInput =
  NullableStringFieldUpdateOperationsInput
  { nullableStringFieldUpdateOperationsInputSet = Nothing
  , nullableStringFieldUpdateOperationsInputUnset = Nothing
  }

-- ** StringFieldUpdateOperationsInput
-- | StringFieldUpdateOperationsInput
data StringFieldUpdateOperationsInput = StringFieldUpdateOperationsInput
  { stringFieldUpdateOperationsInputSet :: !(Maybe Text) -- ^ "set"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StringFieldUpdateOperationsInput
instance A.FromJSON StringFieldUpdateOperationsInput where
  parseJSON = A.withObject "StringFieldUpdateOperationsInput" $ \o ->
    StringFieldUpdateOperationsInput
      <$> (o .:? "set")

-- | ToJSON StringFieldUpdateOperationsInput
instance A.ToJSON StringFieldUpdateOperationsInput where
  toJSON StringFieldUpdateOperationsInput {..} =
   _omitNulls
      [ "set" .= stringFieldUpdateOperationsInputSet
      ]


-- | Construct a value of type 'StringFieldUpdateOperationsInput' (by applying it's required fields, if any)
mkStringFieldUpdateOperationsInput
  :: StringFieldUpdateOperationsInput
mkStringFieldUpdateOperationsInput =
  StringFieldUpdateOperationsInput
  { stringFieldUpdateOperationsInputSet = Nothing
  }

-- ** StringFilter
-- | StringFilter
data StringFilter = StringFilter
  { stringFilterContains :: !(Maybe Text) -- ^ "contains"
  , stringFilterEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , stringFilterEq :: !(Maybe Text) -- ^ "eq"
  , stringFilterEquals :: !(Maybe Text) -- ^ "equals"
  , stringFilterGt :: !(Maybe Text) -- ^ "gt"
  , stringFilterGte :: !(Maybe Text) -- ^ "gte"
  , stringFilterIn :: !(Maybe [Text]) -- ^ "in"
  , stringFilterLt :: !(Maybe Text) -- ^ "lt"
  , stringFilterLte :: !(Maybe Text) -- ^ "lte"
  , stringFilterMode :: !(Maybe QueryMode) -- ^ "mode"
  , stringFilterNot :: !(Maybe NestedStringFilterNot) -- ^ "not"
  , stringFilterNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , stringFilterStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StringFilter
instance A.FromJSON StringFilter where
  parseJSON = A.withObject "StringFilter" $ \o ->
    StringFilter
      <$> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "mode")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON StringFilter
instance A.ToJSON StringFilter where
  toJSON StringFilter {..} =
   _omitNulls
      [ "contains" .= stringFilterContains
      , "endsWith" .= stringFilterEndsWith
      , "eq" .= stringFilterEq
      , "equals" .= stringFilterEquals
      , "gt" .= stringFilterGt
      , "gte" .= stringFilterGte
      , "in" .= stringFilterIn
      , "lt" .= stringFilterLt
      , "lte" .= stringFilterLte
      , "mode" .= stringFilterMode
      , "not" .= stringFilterNot
      , "notIn" .= stringFilterNotIn
      , "startsWith" .= stringFilterStartsWith
      ]


-- | Construct a value of type 'StringFilter' (by applying it's required fields, if any)
mkStringFilter
  :: StringFilter
mkStringFilter =
  StringFilter
  { stringFilterContains = Nothing
  , stringFilterEndsWith = Nothing
  , stringFilterEq = Nothing
  , stringFilterEquals = Nothing
  , stringFilterGt = Nothing
  , stringFilterGte = Nothing
  , stringFilterIn = Nothing
  , stringFilterLt = Nothing
  , stringFilterLte = Nothing
  , stringFilterMode = Nothing
  , stringFilterNot = Nothing
  , stringFilterNotIn = Nothing
  , stringFilterStartsWith = Nothing
  }

-- ** StringNullableFilter
-- | StringNullableFilter
data StringNullableFilter = StringNullableFilter
  { stringNullableFilterContains :: !(Maybe Text) -- ^ "contains"
  , stringNullableFilterEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , stringNullableFilterEq :: !(Maybe Text) -- ^ "eq"
  , stringNullableFilterEquals :: !(Maybe Text) -- ^ "equals"
  , stringNullableFilterGt :: !(Maybe Text) -- ^ "gt"
  , stringNullableFilterGte :: !(Maybe Text) -- ^ "gte"
  , stringNullableFilterIn :: !(Maybe [Text]) -- ^ "in"
  , stringNullableFilterIsSet :: !(Maybe Bool) -- ^ "isSet"
  , stringNullableFilterLt :: !(Maybe Text) -- ^ "lt"
  , stringNullableFilterLte :: !(Maybe Text) -- ^ "lte"
  , stringNullableFilterMode :: !(Maybe QueryMode) -- ^ "mode"
  , stringNullableFilterNot :: !(Maybe NestedStringNullableFilterNot) -- ^ "not"
  , stringNullableFilterNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , stringNullableFilterStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StringNullableFilter
instance A.FromJSON StringNullableFilter where
  parseJSON = A.withObject "StringNullableFilter" $ \o ->
    StringNullableFilter
      <$> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "isSet")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "mode")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON StringNullableFilter
instance A.ToJSON StringNullableFilter where
  toJSON StringNullableFilter {..} =
   _omitNulls
      [ "contains" .= stringNullableFilterContains
      , "endsWith" .= stringNullableFilterEndsWith
      , "eq" .= stringNullableFilterEq
      , "equals" .= stringNullableFilterEquals
      , "gt" .= stringNullableFilterGt
      , "gte" .= stringNullableFilterGte
      , "in" .= stringNullableFilterIn
      , "isSet" .= stringNullableFilterIsSet
      , "lt" .= stringNullableFilterLt
      , "lte" .= stringNullableFilterLte
      , "mode" .= stringNullableFilterMode
      , "not" .= stringNullableFilterNot
      , "notIn" .= stringNullableFilterNotIn
      , "startsWith" .= stringNullableFilterStartsWith
      ]


-- | Construct a value of type 'StringNullableFilter' (by applying it's required fields, if any)
mkStringNullableFilter
  :: StringNullableFilter
mkStringNullableFilter =
  StringNullableFilter
  { stringNullableFilterContains = Nothing
  , stringNullableFilterEndsWith = Nothing
  , stringNullableFilterEq = Nothing
  , stringNullableFilterEquals = Nothing
  , stringNullableFilterGt = Nothing
  , stringNullableFilterGte = Nothing
  , stringNullableFilterIn = Nothing
  , stringNullableFilterIsSet = Nothing
  , stringNullableFilterLt = Nothing
  , stringNullableFilterLte = Nothing
  , stringNullableFilterMode = Nothing
  , stringNullableFilterNot = Nothing
  , stringNullableFilterNotIn = Nothing
  , stringNullableFilterStartsWith = Nothing
  }

-- ** StringNullableWithAggregatesFilter
-- | StringNullableWithAggregatesFilter
data StringNullableWithAggregatesFilter = StringNullableWithAggregatesFilter
  { stringNullableWithAggregatesFilterCount :: !(Maybe NestedIntNullableFilter) -- ^ "_count"
  , stringNullableWithAggregatesFilterMax :: !(Maybe NestedStringNullableFilter) -- ^ "_max"
  , stringNullableWithAggregatesFilterMin :: !(Maybe NestedStringNullableFilter) -- ^ "_min"
  , stringNullableWithAggregatesFilterContains :: !(Maybe Text) -- ^ "contains"
  , stringNullableWithAggregatesFilterEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , stringNullableWithAggregatesFilterEq :: !(Maybe Text) -- ^ "eq"
  , stringNullableWithAggregatesFilterEquals :: !(Maybe Text) -- ^ "equals"
  , stringNullableWithAggregatesFilterGt :: !(Maybe Text) -- ^ "gt"
  , stringNullableWithAggregatesFilterGte :: !(Maybe Text) -- ^ "gte"
  , stringNullableWithAggregatesFilterIn :: !(Maybe [Text]) -- ^ "in"
  , stringNullableWithAggregatesFilterIsSet :: !(Maybe Bool) -- ^ "isSet"
  , stringNullableWithAggregatesFilterLt :: !(Maybe Text) -- ^ "lt"
  , stringNullableWithAggregatesFilterLte :: !(Maybe Text) -- ^ "lte"
  , stringNullableWithAggregatesFilterMode :: !(Maybe QueryMode) -- ^ "mode"
  , stringNullableWithAggregatesFilterNot :: !(Maybe NestedStringNullableWithAggregatesFilterNot) -- ^ "not"
  , stringNullableWithAggregatesFilterNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , stringNullableWithAggregatesFilterStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StringNullableWithAggregatesFilter
instance A.FromJSON StringNullableWithAggregatesFilter where
  parseJSON = A.withObject "StringNullableWithAggregatesFilter" $ \o ->
    StringNullableWithAggregatesFilter
      <$> (o .:? "_count")
      <*> (o .:? "_max")
      <*> (o .:? "_min")
      <*> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "isSet")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "mode")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON StringNullableWithAggregatesFilter
instance A.ToJSON StringNullableWithAggregatesFilter where
  toJSON StringNullableWithAggregatesFilter {..} =
   _omitNulls
      [ "_count" .= stringNullableWithAggregatesFilterCount
      , "_max" .= stringNullableWithAggregatesFilterMax
      , "_min" .= stringNullableWithAggregatesFilterMin
      , "contains" .= stringNullableWithAggregatesFilterContains
      , "endsWith" .= stringNullableWithAggregatesFilterEndsWith
      , "eq" .= stringNullableWithAggregatesFilterEq
      , "equals" .= stringNullableWithAggregatesFilterEquals
      , "gt" .= stringNullableWithAggregatesFilterGt
      , "gte" .= stringNullableWithAggregatesFilterGte
      , "in" .= stringNullableWithAggregatesFilterIn
      , "isSet" .= stringNullableWithAggregatesFilterIsSet
      , "lt" .= stringNullableWithAggregatesFilterLt
      , "lte" .= stringNullableWithAggregatesFilterLte
      , "mode" .= stringNullableWithAggregatesFilterMode
      , "not" .= stringNullableWithAggregatesFilterNot
      , "notIn" .= stringNullableWithAggregatesFilterNotIn
      , "startsWith" .= stringNullableWithAggregatesFilterStartsWith
      ]


-- | Construct a value of type 'StringNullableWithAggregatesFilter' (by applying it's required fields, if any)
mkStringNullableWithAggregatesFilter
  :: StringNullableWithAggregatesFilter
mkStringNullableWithAggregatesFilter =
  StringNullableWithAggregatesFilter
  { stringNullableWithAggregatesFilterCount = Nothing
  , stringNullableWithAggregatesFilterMax = Nothing
  , stringNullableWithAggregatesFilterMin = Nothing
  , stringNullableWithAggregatesFilterContains = Nothing
  , stringNullableWithAggregatesFilterEndsWith = Nothing
  , stringNullableWithAggregatesFilterEq = Nothing
  , stringNullableWithAggregatesFilterEquals = Nothing
  , stringNullableWithAggregatesFilterGt = Nothing
  , stringNullableWithAggregatesFilterGte = Nothing
  , stringNullableWithAggregatesFilterIn = Nothing
  , stringNullableWithAggregatesFilterIsSet = Nothing
  , stringNullableWithAggregatesFilterLt = Nothing
  , stringNullableWithAggregatesFilterLte = Nothing
  , stringNullableWithAggregatesFilterMode = Nothing
  , stringNullableWithAggregatesFilterNot = Nothing
  , stringNullableWithAggregatesFilterNotIn = Nothing
  , stringNullableWithAggregatesFilterStartsWith = Nothing
  }

-- ** StringWithAggregatesFilter
-- | StringWithAggregatesFilter
data StringWithAggregatesFilter = StringWithAggregatesFilter
  { stringWithAggregatesFilterCount :: !(Maybe NestedIntFilter) -- ^ "_count"
  , stringWithAggregatesFilterMax :: !(Maybe NestedStringFilter) -- ^ "_max"
  , stringWithAggregatesFilterMin :: !(Maybe NestedStringFilter) -- ^ "_min"
  , stringWithAggregatesFilterContains :: !(Maybe Text) -- ^ "contains"
  , stringWithAggregatesFilterEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , stringWithAggregatesFilterEq :: !(Maybe Text) -- ^ "eq"
  , stringWithAggregatesFilterEquals :: !(Maybe Text) -- ^ "equals"
  , stringWithAggregatesFilterGt :: !(Maybe Text) -- ^ "gt"
  , stringWithAggregatesFilterGte :: !(Maybe Text) -- ^ "gte"
  , stringWithAggregatesFilterIn :: !(Maybe [Text]) -- ^ "in"
  , stringWithAggregatesFilterLt :: !(Maybe Text) -- ^ "lt"
  , stringWithAggregatesFilterLte :: !(Maybe Text) -- ^ "lte"
  , stringWithAggregatesFilterMode :: !(Maybe QueryMode) -- ^ "mode"
  , stringWithAggregatesFilterNot :: !(Maybe NestedStringWithAggregatesFilterNot) -- ^ "not"
  , stringWithAggregatesFilterNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , stringWithAggregatesFilterStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON StringWithAggregatesFilter
instance A.FromJSON StringWithAggregatesFilter where
  parseJSON = A.withObject "StringWithAggregatesFilter" $ \o ->
    StringWithAggregatesFilter
      <$> (o .:? "_count")
      <*> (o .:? "_max")
      <*> (o .:? "_min")
      <*> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "mode")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON StringWithAggregatesFilter
instance A.ToJSON StringWithAggregatesFilter where
  toJSON StringWithAggregatesFilter {..} =
   _omitNulls
      [ "_count" .= stringWithAggregatesFilterCount
      , "_max" .= stringWithAggregatesFilterMax
      , "_min" .= stringWithAggregatesFilterMin
      , "contains" .= stringWithAggregatesFilterContains
      , "endsWith" .= stringWithAggregatesFilterEndsWith
      , "eq" .= stringWithAggregatesFilterEq
      , "equals" .= stringWithAggregatesFilterEquals
      , "gt" .= stringWithAggregatesFilterGt
      , "gte" .= stringWithAggregatesFilterGte
      , "in" .= stringWithAggregatesFilterIn
      , "lt" .= stringWithAggregatesFilterLt
      , "lte" .= stringWithAggregatesFilterLte
      , "mode" .= stringWithAggregatesFilterMode
      , "not" .= stringWithAggregatesFilterNot
      , "notIn" .= stringWithAggregatesFilterNotIn
      , "startsWith" .= stringWithAggregatesFilterStartsWith
      ]


-- | Construct a value of type 'StringWithAggregatesFilter' (by applying it's required fields, if any)
mkStringWithAggregatesFilter
  :: StringWithAggregatesFilter
mkStringWithAggregatesFilter =
  StringWithAggregatesFilter
  { stringWithAggregatesFilterCount = Nothing
  , stringWithAggregatesFilterMax = Nothing
  , stringWithAggregatesFilterMin = Nothing
  , stringWithAggregatesFilterContains = Nothing
  , stringWithAggregatesFilterEndsWith = Nothing
  , stringWithAggregatesFilterEq = Nothing
  , stringWithAggregatesFilterEquals = Nothing
  , stringWithAggregatesFilterGt = Nothing
  , stringWithAggregatesFilterGte = Nothing
  , stringWithAggregatesFilterIn = Nothing
  , stringWithAggregatesFilterLt = Nothing
  , stringWithAggregatesFilterLte = Nothing
  , stringWithAggregatesFilterMode = Nothing
  , stringWithAggregatesFilterNot = Nothing
  , stringWithAggregatesFilterNotIn = Nothing
  , stringWithAggregatesFilterStartsWith = Nothing
  }

-- ** User
-- | User
data User = User
  { userEmail :: !(Maybe Text) -- ^ "email"
  , userId :: !(Maybe Text) -- ^ "id"
  , userName :: !(Maybe Text) -- ^ "name"
  , userPasswordhash :: !(Maybe Text) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON User
instance A.FromJSON User where
  parseJSON = A.withObject "User" $ \o ->
    User
      <$> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON User
instance A.ToJSON User where
  toJSON User {..} =
   _omitNulls
      [ "email" .= userEmail
      , "id" .= userId
      , "name" .= userName
      , "passwordhash" .= userPasswordhash
      ]


-- | Construct a value of type 'User' (by applying it's required fields, if any)
mkUser
  :: User
mkUser =
  User
  { userEmail = Nothing
  , userId = Nothing
  , userName = Nothing
  , userPasswordhash = Nothing
  }

-- ** UserAggregateInput
-- | UserAggregateInput
data UserAggregateInput = UserAggregateInput
  { userAggregateInputCount :: !(Maybe [E'Count]) -- ^ "_count"
  , userAggregateInputMax :: !(Maybe [E'Max]) -- ^ "_max"
  , userAggregateInputMin :: !(Maybe [E'Max]) -- ^ "_min"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserAggregateInput
instance A.FromJSON UserAggregateInput where
  parseJSON = A.withObject "UserAggregateInput" $ \o ->
    UserAggregateInput
      <$> (o .:? "_count")
      <*> (o .:? "_max")
      <*> (o .:? "_min")

-- | ToJSON UserAggregateInput
instance A.ToJSON UserAggregateInput where
  toJSON UserAggregateInput {..} =
   _omitNulls
      [ "_count" .= userAggregateInputCount
      , "_max" .= userAggregateInputMax
      , "_min" .= userAggregateInputMin
      ]


-- | Construct a value of type 'UserAggregateInput' (by applying it's required fields, if any)
mkUserAggregateInput
  :: UserAggregateInput
mkUserAggregateInput =
  UserAggregateInput
  { userAggregateInputCount = Nothing
  , userAggregateInputMax = Nothing
  , userAggregateInputMin = Nothing
  }

-- ** UserCountAggregateOutputType
-- | UserCountAggregateOutputType
data UserCountAggregateOutputType = UserCountAggregateOutputType
  { userCountAggregateOutputTypeAll :: !(Maybe Int) -- ^ "_all"
  , userCountAggregateOutputTypeEmail :: !(Maybe Int) -- ^ "email"
  , userCountAggregateOutputTypeId :: !(Maybe Int) -- ^ "id"
  , userCountAggregateOutputTypeName :: !(Maybe Int) -- ^ "name"
  , userCountAggregateOutputTypePasswordhash :: !(Maybe Int) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserCountAggregateOutputType
instance A.FromJSON UserCountAggregateOutputType where
  parseJSON = A.withObject "UserCountAggregateOutputType" $ \o ->
    UserCountAggregateOutputType
      <$> (o .:? "_all")
      <*> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserCountAggregateOutputType
instance A.ToJSON UserCountAggregateOutputType where
  toJSON UserCountAggregateOutputType {..} =
   _omitNulls
      [ "_all" .= userCountAggregateOutputTypeAll
      , "email" .= userCountAggregateOutputTypeEmail
      , "id" .= userCountAggregateOutputTypeId
      , "name" .= userCountAggregateOutputTypeName
      , "passwordhash" .= userCountAggregateOutputTypePasswordhash
      ]


-- | Construct a value of type 'UserCountAggregateOutputType' (by applying it's required fields, if any)
mkUserCountAggregateOutputType
  :: UserCountAggregateOutputType
mkUserCountAggregateOutputType =
  UserCountAggregateOutputType
  { userCountAggregateOutputTypeAll = Nothing
  , userCountAggregateOutputTypeEmail = Nothing
  , userCountAggregateOutputTypeId = Nothing
  , userCountAggregateOutputTypeName = Nothing
  , userCountAggregateOutputTypePasswordhash = Nothing
  }

-- ** UserCountOrderByAggregateInput
-- | UserCountOrderByAggregateInput
data UserCountOrderByAggregateInput = UserCountOrderByAggregateInput
  { userCountOrderByAggregateInputEmail :: !(Maybe SortOrder) -- ^ "email"
  , userCountOrderByAggregateInputId :: !(Maybe SortOrder) -- ^ "id"
  , userCountOrderByAggregateInputName :: !(Maybe SortOrder) -- ^ "name"
  , userCountOrderByAggregateInputPasswordhash :: !(Maybe SortOrder) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserCountOrderByAggregateInput
instance A.FromJSON UserCountOrderByAggregateInput where
  parseJSON = A.withObject "UserCountOrderByAggregateInput" $ \o ->
    UserCountOrderByAggregateInput
      <$> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserCountOrderByAggregateInput
instance A.ToJSON UserCountOrderByAggregateInput where
  toJSON UserCountOrderByAggregateInput {..} =
   _omitNulls
      [ "email" .= userCountOrderByAggregateInputEmail
      , "id" .= userCountOrderByAggregateInputId
      , "name" .= userCountOrderByAggregateInputName
      , "passwordhash" .= userCountOrderByAggregateInputPasswordhash
      ]


-- | Construct a value of type 'UserCountOrderByAggregateInput' (by applying it's required fields, if any)
mkUserCountOrderByAggregateInput
  :: UserCountOrderByAggregateInput
mkUserCountOrderByAggregateInput =
  UserCountOrderByAggregateInput
  { userCountOrderByAggregateInputEmail = Nothing
  , userCountOrderByAggregateInputId = Nothing
  , userCountOrderByAggregateInputName = Nothing
  , userCountOrderByAggregateInputPasswordhash = Nothing
  }

-- ** UserCreateInput
-- | UserCreateInput
data UserCreateInput = UserCreateInput
  { userCreateInputEmail :: !(Text) -- ^ /Required/ "email"
  , userCreateInputId :: !(Maybe Text) -- ^ "id"
  , userCreateInputName :: !(Maybe Text) -- ^ "name"
  , userCreateInputPasswordhash :: !(Text) -- ^ /Required/ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserCreateInput
instance A.FromJSON UserCreateInput where
  parseJSON = A.withObject "UserCreateInput" $ \o ->
    UserCreateInput
      <$> (o .:  "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:  "passwordhash")

-- | ToJSON UserCreateInput
instance A.ToJSON UserCreateInput where
  toJSON UserCreateInput {..} =
   _omitNulls
      [ "email" .= userCreateInputEmail
      , "id" .= userCreateInputId
      , "name" .= userCreateInputName
      , "passwordhash" .= userCreateInputPasswordhash
      ]


-- | Construct a value of type 'UserCreateInput' (by applying it's required fields, if any)
mkUserCreateInput
  :: Text -- ^ 'userCreateInputEmail' 
  -> Text -- ^ 'userCreateInputPasswordhash' 
  -> UserCreateInput
mkUserCreateInput userCreateInputEmail userCreateInputPasswordhash =
  UserCreateInput
  { userCreateInputEmail
  , userCreateInputId = Nothing
  , userCreateInputName = Nothing
  , userCreateInputPasswordhash
  }

-- ** UserCreateManyInput
-- | UserCreateManyInput
data UserCreateManyInput = UserCreateManyInput
  { userCreateManyInputEmail :: !(Text) -- ^ /Required/ "email"
  , userCreateManyInputId :: !(Maybe Text) -- ^ "id"
  , userCreateManyInputName :: !(Maybe Text) -- ^ "name"
  , userCreateManyInputPasswordhash :: !(Text) -- ^ /Required/ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserCreateManyInput
instance A.FromJSON UserCreateManyInput where
  parseJSON = A.withObject "UserCreateManyInput" $ \o ->
    UserCreateManyInput
      <$> (o .:  "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:  "passwordhash")

-- | ToJSON UserCreateManyInput
instance A.ToJSON UserCreateManyInput where
  toJSON UserCreateManyInput {..} =
   _omitNulls
      [ "email" .= userCreateManyInputEmail
      , "id" .= userCreateManyInputId
      , "name" .= userCreateManyInputName
      , "passwordhash" .= userCreateManyInputPasswordhash
      ]


-- | Construct a value of type 'UserCreateManyInput' (by applying it's required fields, if any)
mkUserCreateManyInput
  :: Text -- ^ 'userCreateManyInputEmail' 
  -> Text -- ^ 'userCreateManyInputPasswordhash' 
  -> UserCreateManyInput
mkUserCreateManyInput userCreateManyInputEmail userCreateManyInputPasswordhash =
  UserCreateManyInput
  { userCreateManyInputEmail
  , userCreateManyInputId = Nothing
  , userCreateManyInputName = Nothing
  , userCreateManyInputPasswordhash
  }

-- ** UserGroupByInput
-- | UserGroupByInput
data UserGroupByInput = UserGroupByInput
  { userGroupByInputCount :: !(Maybe [E'Count]) -- ^ "_count"
  , userGroupByInputMax :: !(Maybe [E'Max]) -- ^ "_max"
  , userGroupByInputMin :: !(Maybe [E'Max]) -- ^ "_min"
  , userGroupByInputEmail :: !(Maybe Bool) -- ^ "email"
  , userGroupByInputId :: !(Maybe Bool) -- ^ "id"
  , userGroupByInputName :: !(Maybe Bool) -- ^ "name"
  , userGroupByInputPasswordhash :: !(Maybe Bool) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserGroupByInput
instance A.FromJSON UserGroupByInput where
  parseJSON = A.withObject "UserGroupByInput" $ \o ->
    UserGroupByInput
      <$> (o .:? "_count")
      <*> (o .:? "_max")
      <*> (o .:? "_min")
      <*> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserGroupByInput
instance A.ToJSON UserGroupByInput where
  toJSON UserGroupByInput {..} =
   _omitNulls
      [ "_count" .= userGroupByInputCount
      , "_max" .= userGroupByInputMax
      , "_min" .= userGroupByInputMin
      , "email" .= userGroupByInputEmail
      , "id" .= userGroupByInputId
      , "name" .= userGroupByInputName
      , "passwordhash" .= userGroupByInputPasswordhash
      ]


-- | Construct a value of type 'UserGroupByInput' (by applying it's required fields, if any)
mkUserGroupByInput
  :: UserGroupByInput
mkUserGroupByInput =
  UserGroupByInput
  { userGroupByInputCount = Nothing
  , userGroupByInputMax = Nothing
  , userGroupByInputMin = Nothing
  , userGroupByInputEmail = Nothing
  , userGroupByInputId = Nothing
  , userGroupByInputName = Nothing
  , userGroupByInputPasswordhash = Nothing
  }

-- ** UserGroupByOutputType
-- | UserGroupByOutputType
data UserGroupByOutputType = UserGroupByOutputType
  { userGroupByOutputTypeCount :: !(Maybe UserCountAggregateOutputType) -- ^ "_count"
  , userGroupByOutputTypeMax :: !(Maybe UserMaxAggregateOutputType) -- ^ "_max"
  , userGroupByOutputTypeMin :: !(Maybe UserMinAggregateOutputType) -- ^ "_min"
  , userGroupByOutputTypeEmail :: !(Maybe Text) -- ^ "email"
  , userGroupByOutputTypeId :: !(Maybe Text) -- ^ "id"
  , userGroupByOutputTypeName :: !(Maybe Text) -- ^ "name"
  , userGroupByOutputTypePasswordhash :: !(Maybe Text) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserGroupByOutputType
instance A.FromJSON UserGroupByOutputType where
  parseJSON = A.withObject "UserGroupByOutputType" $ \o ->
    UserGroupByOutputType
      <$> (o .:? "_count")
      <*> (o .:? "_max")
      <*> (o .:? "_min")
      <*> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserGroupByOutputType
instance A.ToJSON UserGroupByOutputType where
  toJSON UserGroupByOutputType {..} =
   _omitNulls
      [ "_count" .= userGroupByOutputTypeCount
      , "_max" .= userGroupByOutputTypeMax
      , "_min" .= userGroupByOutputTypeMin
      , "email" .= userGroupByOutputTypeEmail
      , "id" .= userGroupByOutputTypeId
      , "name" .= userGroupByOutputTypeName
      , "passwordhash" .= userGroupByOutputTypePasswordhash
      ]


-- | Construct a value of type 'UserGroupByOutputType' (by applying it's required fields, if any)
mkUserGroupByOutputType
  :: UserGroupByOutputType
mkUserGroupByOutputType =
  UserGroupByOutputType
  { userGroupByOutputTypeCount = Nothing
  , userGroupByOutputTypeMax = Nothing
  , userGroupByOutputTypeMin = Nothing
  , userGroupByOutputTypeEmail = Nothing
  , userGroupByOutputTypeId = Nothing
  , userGroupByOutputTypeName = Nothing
  , userGroupByOutputTypePasswordhash = Nothing
  }

-- ** UserMaxAggregateOutputType
-- | UserMaxAggregateOutputType
data UserMaxAggregateOutputType = UserMaxAggregateOutputType
  { userMaxAggregateOutputTypeEmail :: !(Maybe Text) -- ^ "email"
  , userMaxAggregateOutputTypeId :: !(Maybe Text) -- ^ "id"
  , userMaxAggregateOutputTypeName :: !(Maybe Text) -- ^ "name"
  , userMaxAggregateOutputTypePasswordhash :: !(Maybe Text) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserMaxAggregateOutputType
instance A.FromJSON UserMaxAggregateOutputType where
  parseJSON = A.withObject "UserMaxAggregateOutputType" $ \o ->
    UserMaxAggregateOutputType
      <$> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserMaxAggregateOutputType
instance A.ToJSON UserMaxAggregateOutputType where
  toJSON UserMaxAggregateOutputType {..} =
   _omitNulls
      [ "email" .= userMaxAggregateOutputTypeEmail
      , "id" .= userMaxAggregateOutputTypeId
      , "name" .= userMaxAggregateOutputTypeName
      , "passwordhash" .= userMaxAggregateOutputTypePasswordhash
      ]


-- | Construct a value of type 'UserMaxAggregateOutputType' (by applying it's required fields, if any)
mkUserMaxAggregateOutputType
  :: UserMaxAggregateOutputType
mkUserMaxAggregateOutputType =
  UserMaxAggregateOutputType
  { userMaxAggregateOutputTypeEmail = Nothing
  , userMaxAggregateOutputTypeId = Nothing
  , userMaxAggregateOutputTypeName = Nothing
  , userMaxAggregateOutputTypePasswordhash = Nothing
  }

-- ** UserMaxOrderByAggregateInput
-- | UserMaxOrderByAggregateInput
data UserMaxOrderByAggregateInput = UserMaxOrderByAggregateInput
  { userMaxOrderByAggregateInputEmail :: !(Maybe SortOrder) -- ^ "email"
  , userMaxOrderByAggregateInputId :: !(Maybe SortOrder) -- ^ "id"
  , userMaxOrderByAggregateInputName :: !(Maybe SortOrder) -- ^ "name"
  , userMaxOrderByAggregateInputPasswordhash :: !(Maybe SortOrder) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserMaxOrderByAggregateInput
instance A.FromJSON UserMaxOrderByAggregateInput where
  parseJSON = A.withObject "UserMaxOrderByAggregateInput" $ \o ->
    UserMaxOrderByAggregateInput
      <$> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserMaxOrderByAggregateInput
instance A.ToJSON UserMaxOrderByAggregateInput where
  toJSON UserMaxOrderByAggregateInput {..} =
   _omitNulls
      [ "email" .= userMaxOrderByAggregateInputEmail
      , "id" .= userMaxOrderByAggregateInputId
      , "name" .= userMaxOrderByAggregateInputName
      , "passwordhash" .= userMaxOrderByAggregateInputPasswordhash
      ]


-- | Construct a value of type 'UserMaxOrderByAggregateInput' (by applying it's required fields, if any)
mkUserMaxOrderByAggregateInput
  :: UserMaxOrderByAggregateInput
mkUserMaxOrderByAggregateInput =
  UserMaxOrderByAggregateInput
  { userMaxOrderByAggregateInputEmail = Nothing
  , userMaxOrderByAggregateInputId = Nothing
  , userMaxOrderByAggregateInputName = Nothing
  , userMaxOrderByAggregateInputPasswordhash = Nothing
  }

-- ** UserMinAggregateOutputType
-- | UserMinAggregateOutputType
data UserMinAggregateOutputType = UserMinAggregateOutputType
  { userMinAggregateOutputTypeEmail :: !(Maybe Text) -- ^ "email"
  , userMinAggregateOutputTypeId :: !(Maybe Text) -- ^ "id"
  , userMinAggregateOutputTypeName :: !(Maybe Text) -- ^ "name"
  , userMinAggregateOutputTypePasswordhash :: !(Maybe Text) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserMinAggregateOutputType
instance A.FromJSON UserMinAggregateOutputType where
  parseJSON = A.withObject "UserMinAggregateOutputType" $ \o ->
    UserMinAggregateOutputType
      <$> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserMinAggregateOutputType
instance A.ToJSON UserMinAggregateOutputType where
  toJSON UserMinAggregateOutputType {..} =
   _omitNulls
      [ "email" .= userMinAggregateOutputTypeEmail
      , "id" .= userMinAggregateOutputTypeId
      , "name" .= userMinAggregateOutputTypeName
      , "passwordhash" .= userMinAggregateOutputTypePasswordhash
      ]


-- | Construct a value of type 'UserMinAggregateOutputType' (by applying it's required fields, if any)
mkUserMinAggregateOutputType
  :: UserMinAggregateOutputType
mkUserMinAggregateOutputType =
  UserMinAggregateOutputType
  { userMinAggregateOutputTypeEmail = Nothing
  , userMinAggregateOutputTypeId = Nothing
  , userMinAggregateOutputTypeName = Nothing
  , userMinAggregateOutputTypePasswordhash = Nothing
  }

-- ** UserMinOrderByAggregateInput
-- | UserMinOrderByAggregateInput
data UserMinOrderByAggregateInput = UserMinOrderByAggregateInput
  { userMinOrderByAggregateInputEmail :: !(Maybe SortOrder) -- ^ "email"
  , userMinOrderByAggregateInputId :: !(Maybe SortOrder) -- ^ "id"
  , userMinOrderByAggregateInputName :: !(Maybe SortOrder) -- ^ "name"
  , userMinOrderByAggregateInputPasswordhash :: !(Maybe SortOrder) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserMinOrderByAggregateInput
instance A.FromJSON UserMinOrderByAggregateInput where
  parseJSON = A.withObject "UserMinOrderByAggregateInput" $ \o ->
    UserMinOrderByAggregateInput
      <$> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserMinOrderByAggregateInput
instance A.ToJSON UserMinOrderByAggregateInput where
  toJSON UserMinOrderByAggregateInput {..} =
   _omitNulls
      [ "email" .= userMinOrderByAggregateInputEmail
      , "id" .= userMinOrderByAggregateInputId
      , "name" .= userMinOrderByAggregateInputName
      , "passwordhash" .= userMinOrderByAggregateInputPasswordhash
      ]


-- | Construct a value of type 'UserMinOrderByAggregateInput' (by applying it's required fields, if any)
mkUserMinOrderByAggregateInput
  :: UserMinOrderByAggregateInput
mkUserMinOrderByAggregateInput =
  UserMinOrderByAggregateInput
  { userMinOrderByAggregateInputEmail = Nothing
  , userMinOrderByAggregateInputId = Nothing
  , userMinOrderByAggregateInputName = Nothing
  , userMinOrderByAggregateInputPasswordhash = Nothing
  }

-- ** UserOrderByWithAggregationInput
-- | UserOrderByWithAggregationInput
data UserOrderByWithAggregationInput = UserOrderByWithAggregationInput
  { userOrderByWithAggregationInputCount :: !(Maybe UserCountOrderByAggregateInput) -- ^ "_count"
  , userOrderByWithAggregationInputMax :: !(Maybe UserMaxOrderByAggregateInput) -- ^ "_max"
  , userOrderByWithAggregationInputMin :: !(Maybe UserMinOrderByAggregateInput) -- ^ "_min"
  , userOrderByWithAggregationInputEmail :: !(Maybe SortOrder) -- ^ "email"
  , userOrderByWithAggregationInputId :: !(Maybe SortOrder) -- ^ "id"
  , userOrderByWithAggregationInputName :: !(Maybe SortOrder) -- ^ "name"
  , userOrderByWithAggregationInputPasswordhash :: !(Maybe SortOrder) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserOrderByWithAggregationInput
instance A.FromJSON UserOrderByWithAggregationInput where
  parseJSON = A.withObject "UserOrderByWithAggregationInput" $ \o ->
    UserOrderByWithAggregationInput
      <$> (o .:? "_count")
      <*> (o .:? "_max")
      <*> (o .:? "_min")
      <*> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserOrderByWithAggregationInput
instance A.ToJSON UserOrderByWithAggregationInput where
  toJSON UserOrderByWithAggregationInput {..} =
   _omitNulls
      [ "_count" .= userOrderByWithAggregationInputCount
      , "_max" .= userOrderByWithAggregationInputMax
      , "_min" .= userOrderByWithAggregationInputMin
      , "email" .= userOrderByWithAggregationInputEmail
      , "id" .= userOrderByWithAggregationInputId
      , "name" .= userOrderByWithAggregationInputName
      , "passwordhash" .= userOrderByWithAggregationInputPasswordhash
      ]


-- | Construct a value of type 'UserOrderByWithAggregationInput' (by applying it's required fields, if any)
mkUserOrderByWithAggregationInput
  :: UserOrderByWithAggregationInput
mkUserOrderByWithAggregationInput =
  UserOrderByWithAggregationInput
  { userOrderByWithAggregationInputCount = Nothing
  , userOrderByWithAggregationInputMax = Nothing
  , userOrderByWithAggregationInputMin = Nothing
  , userOrderByWithAggregationInputEmail = Nothing
  , userOrderByWithAggregationInputId = Nothing
  , userOrderByWithAggregationInputName = Nothing
  , userOrderByWithAggregationInputPasswordhash = Nothing
  }

-- ** UserOrderByWithRelationInput
-- | UserOrderByWithRelationInput
data UserOrderByWithRelationInput = UserOrderByWithRelationInput
  { userOrderByWithRelationInputEmail :: !(Maybe SortOrder) -- ^ "email"
  , userOrderByWithRelationInputId :: !(Maybe SortOrder) -- ^ "id"
  , userOrderByWithRelationInputName :: !(Maybe SortOrder) -- ^ "name"
  , userOrderByWithRelationInputPasswordhash :: !(Maybe SortOrder) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserOrderByWithRelationInput
instance A.FromJSON UserOrderByWithRelationInput where
  parseJSON = A.withObject "UserOrderByWithRelationInput" $ \o ->
    UserOrderByWithRelationInput
      <$> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserOrderByWithRelationInput
instance A.ToJSON UserOrderByWithRelationInput where
  toJSON UserOrderByWithRelationInput {..} =
   _omitNulls
      [ "email" .= userOrderByWithRelationInputEmail
      , "id" .= userOrderByWithRelationInputId
      , "name" .= userOrderByWithRelationInputName
      , "passwordhash" .= userOrderByWithRelationInputPasswordhash
      ]


-- | Construct a value of type 'UserOrderByWithRelationInput' (by applying it's required fields, if any)
mkUserOrderByWithRelationInput
  :: UserOrderByWithRelationInput
mkUserOrderByWithRelationInput =
  UserOrderByWithRelationInput
  { userOrderByWithRelationInputEmail = Nothing
  , userOrderByWithRelationInputId = Nothing
  , userOrderByWithRelationInputName = Nothing
  , userOrderByWithRelationInputPasswordhash = Nothing
  }

-- ** UserScalarWhereWithAggregatesInput
-- | UserScalarWhereWithAggregatesInput
data UserScalarWhereWithAggregatesInput = UserScalarWhereWithAggregatesInput
  { userScalarWhereWithAggregatesInputAnd :: !(Maybe UserScalarWhereWithAggregatesInputAND) -- ^ "AND"
  , userScalarWhereWithAggregatesInputNot :: !(Maybe UserScalarWhereWithAggregatesInputAND) -- ^ "NOT"
  , userScalarWhereWithAggregatesInputOr :: !(Maybe [UserScalarWhereWithAggregatesInput]) -- ^ "OR"
  , userScalarWhereWithAggregatesInputEmail :: !(Maybe UserScalarWhereWithAggregatesInputEmail) -- ^ "email"
  , userScalarWhereWithAggregatesInputId :: !(Maybe UserScalarWhereWithAggregatesInputEmail) -- ^ "id"
  , userScalarWhereWithAggregatesInputName :: !(Maybe UserScalarWhereWithAggregatesInputName) -- ^ "name"
  , userScalarWhereWithAggregatesInputPasswordhash :: !(Maybe UserScalarWhereWithAggregatesInputEmail) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserScalarWhereWithAggregatesInput
instance A.FromJSON UserScalarWhereWithAggregatesInput where
  parseJSON = A.withObject "UserScalarWhereWithAggregatesInput" $ \o ->
    UserScalarWhereWithAggregatesInput
      <$> (o .:? "AND")
      <*> (o .:? "NOT")
      <*> (o .:? "OR")
      <*> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserScalarWhereWithAggregatesInput
instance A.ToJSON UserScalarWhereWithAggregatesInput where
  toJSON UserScalarWhereWithAggregatesInput {..} =
   _omitNulls
      [ "AND" .= userScalarWhereWithAggregatesInputAnd
      , "NOT" .= userScalarWhereWithAggregatesInputNot
      , "OR" .= userScalarWhereWithAggregatesInputOr
      , "email" .= userScalarWhereWithAggregatesInputEmail
      , "id" .= userScalarWhereWithAggregatesInputId
      , "name" .= userScalarWhereWithAggregatesInputName
      , "passwordhash" .= userScalarWhereWithAggregatesInputPasswordhash
      ]


-- | Construct a value of type 'UserScalarWhereWithAggregatesInput' (by applying it's required fields, if any)
mkUserScalarWhereWithAggregatesInput
  :: UserScalarWhereWithAggregatesInput
mkUserScalarWhereWithAggregatesInput =
  UserScalarWhereWithAggregatesInput
  { userScalarWhereWithAggregatesInputAnd = Nothing
  , userScalarWhereWithAggregatesInputNot = Nothing
  , userScalarWhereWithAggregatesInputOr = Nothing
  , userScalarWhereWithAggregatesInputEmail = Nothing
  , userScalarWhereWithAggregatesInputId = Nothing
  , userScalarWhereWithAggregatesInputName = Nothing
  , userScalarWhereWithAggregatesInputPasswordhash = Nothing
  }

-- ** UserScalarWhereWithAggregatesInputAND
-- | UserScalarWhereWithAggregatesInputAND
data UserScalarWhereWithAggregatesInputAND = UserScalarWhereWithAggregatesInputAND
  { userScalarWhereWithAggregatesInputANDAnd :: !(Maybe UserScalarWhereWithAggregatesInputAND) -- ^ "AND"
  , userScalarWhereWithAggregatesInputANDNot :: !(Maybe UserScalarWhereWithAggregatesInputAND) -- ^ "NOT"
  , userScalarWhereWithAggregatesInputANDOr :: !(Maybe [UserScalarWhereWithAggregatesInput]) -- ^ "OR"
  , userScalarWhereWithAggregatesInputANDEmail :: !(Maybe UserScalarWhereWithAggregatesInputEmail) -- ^ "email"
  , userScalarWhereWithAggregatesInputANDId :: !(Maybe UserScalarWhereWithAggregatesInputEmail) -- ^ "id"
  , userScalarWhereWithAggregatesInputANDName :: !(Maybe UserScalarWhereWithAggregatesInputName) -- ^ "name"
  , userScalarWhereWithAggregatesInputANDPasswordhash :: !(Maybe UserScalarWhereWithAggregatesInputEmail) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserScalarWhereWithAggregatesInputAND
instance A.FromJSON UserScalarWhereWithAggregatesInputAND where
  parseJSON = A.withObject "UserScalarWhereWithAggregatesInputAND" $ \o ->
    UserScalarWhereWithAggregatesInputAND
      <$> (o .:? "AND")
      <*> (o .:? "NOT")
      <*> (o .:? "OR")
      <*> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserScalarWhereWithAggregatesInputAND
instance A.ToJSON UserScalarWhereWithAggregatesInputAND where
  toJSON UserScalarWhereWithAggregatesInputAND {..} =
   _omitNulls
      [ "AND" .= userScalarWhereWithAggregatesInputANDAnd
      , "NOT" .= userScalarWhereWithAggregatesInputANDNot
      , "OR" .= userScalarWhereWithAggregatesInputANDOr
      , "email" .= userScalarWhereWithAggregatesInputANDEmail
      , "id" .= userScalarWhereWithAggregatesInputANDId
      , "name" .= userScalarWhereWithAggregatesInputANDName
      , "passwordhash" .= userScalarWhereWithAggregatesInputANDPasswordhash
      ]


-- | Construct a value of type 'UserScalarWhereWithAggregatesInputAND' (by applying it's required fields, if any)
mkUserScalarWhereWithAggregatesInputAND
  :: UserScalarWhereWithAggregatesInputAND
mkUserScalarWhereWithAggregatesInputAND =
  UserScalarWhereWithAggregatesInputAND
  { userScalarWhereWithAggregatesInputANDAnd = Nothing
  , userScalarWhereWithAggregatesInputANDNot = Nothing
  , userScalarWhereWithAggregatesInputANDOr = Nothing
  , userScalarWhereWithAggregatesInputANDEmail = Nothing
  , userScalarWhereWithAggregatesInputANDId = Nothing
  , userScalarWhereWithAggregatesInputANDName = Nothing
  , userScalarWhereWithAggregatesInputANDPasswordhash = Nothing
  }

-- ** UserScalarWhereWithAggregatesInputEmail
-- | UserScalarWhereWithAggregatesInputEmail
data UserScalarWhereWithAggregatesInputEmail = UserScalarWhereWithAggregatesInputEmail
  { userScalarWhereWithAggregatesInputEmailCount :: !(Maybe NestedIntFilter) -- ^ "_count"
  , userScalarWhereWithAggregatesInputEmailMax :: !(Maybe NestedStringFilter) -- ^ "_max"
  , userScalarWhereWithAggregatesInputEmailMin :: !(Maybe NestedStringFilter) -- ^ "_min"
  , userScalarWhereWithAggregatesInputEmailContains :: !(Maybe Text) -- ^ "contains"
  , userScalarWhereWithAggregatesInputEmailEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , userScalarWhereWithAggregatesInputEmailEq :: !(Maybe Text) -- ^ "eq"
  , userScalarWhereWithAggregatesInputEmailEquals :: !(Maybe Text) -- ^ "equals"
  , userScalarWhereWithAggregatesInputEmailGt :: !(Maybe Text) -- ^ "gt"
  , userScalarWhereWithAggregatesInputEmailGte :: !(Maybe Text) -- ^ "gte"
  , userScalarWhereWithAggregatesInputEmailIn :: !(Maybe [Text]) -- ^ "in"
  , userScalarWhereWithAggregatesInputEmailLt :: !(Maybe Text) -- ^ "lt"
  , userScalarWhereWithAggregatesInputEmailLte :: !(Maybe Text) -- ^ "lte"
  , userScalarWhereWithAggregatesInputEmailMode :: !(Maybe QueryMode) -- ^ "mode"
  , userScalarWhereWithAggregatesInputEmailNot :: !(Maybe NestedStringWithAggregatesFilterNot) -- ^ "not"
  , userScalarWhereWithAggregatesInputEmailNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , userScalarWhereWithAggregatesInputEmailStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserScalarWhereWithAggregatesInputEmail
instance A.FromJSON UserScalarWhereWithAggregatesInputEmail where
  parseJSON = A.withObject "UserScalarWhereWithAggregatesInputEmail" $ \o ->
    UserScalarWhereWithAggregatesInputEmail
      <$> (o .:? "_count")
      <*> (o .:? "_max")
      <*> (o .:? "_min")
      <*> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "mode")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON UserScalarWhereWithAggregatesInputEmail
instance A.ToJSON UserScalarWhereWithAggregatesInputEmail where
  toJSON UserScalarWhereWithAggregatesInputEmail {..} =
   _omitNulls
      [ "_count" .= userScalarWhereWithAggregatesInputEmailCount
      , "_max" .= userScalarWhereWithAggregatesInputEmailMax
      , "_min" .= userScalarWhereWithAggregatesInputEmailMin
      , "contains" .= userScalarWhereWithAggregatesInputEmailContains
      , "endsWith" .= userScalarWhereWithAggregatesInputEmailEndsWith
      , "eq" .= userScalarWhereWithAggregatesInputEmailEq
      , "equals" .= userScalarWhereWithAggregatesInputEmailEquals
      , "gt" .= userScalarWhereWithAggregatesInputEmailGt
      , "gte" .= userScalarWhereWithAggregatesInputEmailGte
      , "in" .= userScalarWhereWithAggregatesInputEmailIn
      , "lt" .= userScalarWhereWithAggregatesInputEmailLt
      , "lte" .= userScalarWhereWithAggregatesInputEmailLte
      , "mode" .= userScalarWhereWithAggregatesInputEmailMode
      , "not" .= userScalarWhereWithAggregatesInputEmailNot
      , "notIn" .= userScalarWhereWithAggregatesInputEmailNotIn
      , "startsWith" .= userScalarWhereWithAggregatesInputEmailStartsWith
      ]


-- | Construct a value of type 'UserScalarWhereWithAggregatesInputEmail' (by applying it's required fields, if any)
mkUserScalarWhereWithAggregatesInputEmail
  :: UserScalarWhereWithAggregatesInputEmail
mkUserScalarWhereWithAggregatesInputEmail =
  UserScalarWhereWithAggregatesInputEmail
  { userScalarWhereWithAggregatesInputEmailCount = Nothing
  , userScalarWhereWithAggregatesInputEmailMax = Nothing
  , userScalarWhereWithAggregatesInputEmailMin = Nothing
  , userScalarWhereWithAggregatesInputEmailContains = Nothing
  , userScalarWhereWithAggregatesInputEmailEndsWith = Nothing
  , userScalarWhereWithAggregatesInputEmailEq = Nothing
  , userScalarWhereWithAggregatesInputEmailEquals = Nothing
  , userScalarWhereWithAggregatesInputEmailGt = Nothing
  , userScalarWhereWithAggregatesInputEmailGte = Nothing
  , userScalarWhereWithAggregatesInputEmailIn = Nothing
  , userScalarWhereWithAggregatesInputEmailLt = Nothing
  , userScalarWhereWithAggregatesInputEmailLte = Nothing
  , userScalarWhereWithAggregatesInputEmailMode = Nothing
  , userScalarWhereWithAggregatesInputEmailNot = Nothing
  , userScalarWhereWithAggregatesInputEmailNotIn = Nothing
  , userScalarWhereWithAggregatesInputEmailStartsWith = Nothing
  }

-- ** UserScalarWhereWithAggregatesInputName
-- | UserScalarWhereWithAggregatesInputName
data UserScalarWhereWithAggregatesInputName = UserScalarWhereWithAggregatesInputName
  { userScalarWhereWithAggregatesInputNameCount :: !(Maybe NestedIntNullableFilter) -- ^ "_count"
  , userScalarWhereWithAggregatesInputNameMax :: !(Maybe NestedStringNullableFilter) -- ^ "_max"
  , userScalarWhereWithAggregatesInputNameMin :: !(Maybe NestedStringNullableFilter) -- ^ "_min"
  , userScalarWhereWithAggregatesInputNameContains :: !(Maybe Text) -- ^ "contains"
  , userScalarWhereWithAggregatesInputNameEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , userScalarWhereWithAggregatesInputNameEq :: !(Maybe Text) -- ^ "eq"
  , userScalarWhereWithAggregatesInputNameEquals :: !(Maybe Text) -- ^ "equals"
  , userScalarWhereWithAggregatesInputNameGt :: !(Maybe Text) -- ^ "gt"
  , userScalarWhereWithAggregatesInputNameGte :: !(Maybe Text) -- ^ "gte"
  , userScalarWhereWithAggregatesInputNameIn :: !(Maybe [Text]) -- ^ "in"
  , userScalarWhereWithAggregatesInputNameIsSet :: !(Maybe Bool) -- ^ "isSet"
  , userScalarWhereWithAggregatesInputNameLt :: !(Maybe Text) -- ^ "lt"
  , userScalarWhereWithAggregatesInputNameLte :: !(Maybe Text) -- ^ "lte"
  , userScalarWhereWithAggregatesInputNameMode :: !(Maybe QueryMode) -- ^ "mode"
  , userScalarWhereWithAggregatesInputNameNot :: !(Maybe NestedStringNullableWithAggregatesFilterNot) -- ^ "not"
  , userScalarWhereWithAggregatesInputNameNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , userScalarWhereWithAggregatesInputNameStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserScalarWhereWithAggregatesInputName
instance A.FromJSON UserScalarWhereWithAggregatesInputName where
  parseJSON = A.withObject "UserScalarWhereWithAggregatesInputName" $ \o ->
    UserScalarWhereWithAggregatesInputName
      <$> (o .:? "_count")
      <*> (o .:? "_max")
      <*> (o .:? "_min")
      <*> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "isSet")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "mode")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON UserScalarWhereWithAggregatesInputName
instance A.ToJSON UserScalarWhereWithAggregatesInputName where
  toJSON UserScalarWhereWithAggregatesInputName {..} =
   _omitNulls
      [ "_count" .= userScalarWhereWithAggregatesInputNameCount
      , "_max" .= userScalarWhereWithAggregatesInputNameMax
      , "_min" .= userScalarWhereWithAggregatesInputNameMin
      , "contains" .= userScalarWhereWithAggregatesInputNameContains
      , "endsWith" .= userScalarWhereWithAggregatesInputNameEndsWith
      , "eq" .= userScalarWhereWithAggregatesInputNameEq
      , "equals" .= userScalarWhereWithAggregatesInputNameEquals
      , "gt" .= userScalarWhereWithAggregatesInputNameGt
      , "gte" .= userScalarWhereWithAggregatesInputNameGte
      , "in" .= userScalarWhereWithAggregatesInputNameIn
      , "isSet" .= userScalarWhereWithAggregatesInputNameIsSet
      , "lt" .= userScalarWhereWithAggregatesInputNameLt
      , "lte" .= userScalarWhereWithAggregatesInputNameLte
      , "mode" .= userScalarWhereWithAggregatesInputNameMode
      , "not" .= userScalarWhereWithAggregatesInputNameNot
      , "notIn" .= userScalarWhereWithAggregatesInputNameNotIn
      , "startsWith" .= userScalarWhereWithAggregatesInputNameStartsWith
      ]


-- | Construct a value of type 'UserScalarWhereWithAggregatesInputName' (by applying it's required fields, if any)
mkUserScalarWhereWithAggregatesInputName
  :: UserScalarWhereWithAggregatesInputName
mkUserScalarWhereWithAggregatesInputName =
  UserScalarWhereWithAggregatesInputName
  { userScalarWhereWithAggregatesInputNameCount = Nothing
  , userScalarWhereWithAggregatesInputNameMax = Nothing
  , userScalarWhereWithAggregatesInputNameMin = Nothing
  , userScalarWhereWithAggregatesInputNameContains = Nothing
  , userScalarWhereWithAggregatesInputNameEndsWith = Nothing
  , userScalarWhereWithAggregatesInputNameEq = Nothing
  , userScalarWhereWithAggregatesInputNameEquals = Nothing
  , userScalarWhereWithAggregatesInputNameGt = Nothing
  , userScalarWhereWithAggregatesInputNameGte = Nothing
  , userScalarWhereWithAggregatesInputNameIn = Nothing
  , userScalarWhereWithAggregatesInputNameIsSet = Nothing
  , userScalarWhereWithAggregatesInputNameLt = Nothing
  , userScalarWhereWithAggregatesInputNameLte = Nothing
  , userScalarWhereWithAggregatesInputNameMode = Nothing
  , userScalarWhereWithAggregatesInputNameNot = Nothing
  , userScalarWhereWithAggregatesInputNameNotIn = Nothing
  , userScalarWhereWithAggregatesInputNameStartsWith = Nothing
  }

-- ** UserSelectInput
-- | UserSelectInput
data UserSelectInput = UserSelectInput
  { userSelectInputRelated :: !(Maybe Bool) -- ^ "$related"
  , userSelectInputScalars :: !(Maybe Bool) -- ^ "$scalars"
  , userSelectInputEmail :: !(Maybe Bool) -- ^ "email"
  , userSelectInputId :: !(Maybe Bool) -- ^ "id"
  , userSelectInputName :: !(Maybe Bool) -- ^ "name"
  , userSelectInputPasswordhash :: !(Maybe Bool) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserSelectInput
instance A.FromJSON UserSelectInput where
  parseJSON = A.withObject "UserSelectInput" $ \o ->
    UserSelectInput
      <$> (o .:? "$related")
      <*> (o .:? "$scalars")
      <*> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserSelectInput
instance A.ToJSON UserSelectInput where
  toJSON UserSelectInput {..} =
   _omitNulls
      [ "$related" .= userSelectInputRelated
      , "$scalars" .= userSelectInputScalars
      , "email" .= userSelectInputEmail
      , "id" .= userSelectInputId
      , "name" .= userSelectInputName
      , "passwordhash" .= userSelectInputPasswordhash
      ]


-- | Construct a value of type 'UserSelectInput' (by applying it's required fields, if any)
mkUserSelectInput
  :: UserSelectInput
mkUserSelectInput =
  UserSelectInput
  { userSelectInputRelated = Nothing
  , userSelectInputScalars = Nothing
  , userSelectInputEmail = Nothing
  , userSelectInputId = Nothing
  , userSelectInputName = Nothing
  , userSelectInputPasswordhash = Nothing
  }

-- ** UserUpdateInput
-- | UserUpdateInput
data UserUpdateInput = UserUpdateInput
  { userUpdateInputEmail :: !(Maybe UserUpdateInputEmail) -- ^ "email"
  , userUpdateInputName :: !(Maybe UserUpdateInputName) -- ^ "name"
  , userUpdateInputPasswordhash :: !(Maybe UserUpdateInputEmail) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserUpdateInput
instance A.FromJSON UserUpdateInput where
  parseJSON = A.withObject "UserUpdateInput" $ \o ->
    UserUpdateInput
      <$> (o .:? "email")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserUpdateInput
instance A.ToJSON UserUpdateInput where
  toJSON UserUpdateInput {..} =
   _omitNulls
      [ "email" .= userUpdateInputEmail
      , "name" .= userUpdateInputName
      , "passwordhash" .= userUpdateInputPasswordhash
      ]


-- | Construct a value of type 'UserUpdateInput' (by applying it's required fields, if any)
mkUserUpdateInput
  :: UserUpdateInput
mkUserUpdateInput =
  UserUpdateInput
  { userUpdateInputEmail = Nothing
  , userUpdateInputName = Nothing
  , userUpdateInputPasswordhash = Nothing
  }

-- ** UserUpdateInputEmail
-- | UserUpdateInputEmail
data UserUpdateInputEmail = UserUpdateInputEmail
  { userUpdateInputEmailSet :: !(Maybe Text) -- ^ "set"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserUpdateInputEmail
instance A.FromJSON UserUpdateInputEmail where
  parseJSON = A.withObject "UserUpdateInputEmail" $ \o ->
    UserUpdateInputEmail
      <$> (o .:? "set")

-- | ToJSON UserUpdateInputEmail
instance A.ToJSON UserUpdateInputEmail where
  toJSON UserUpdateInputEmail {..} =
   _omitNulls
      [ "set" .= userUpdateInputEmailSet
      ]


-- | Construct a value of type 'UserUpdateInputEmail' (by applying it's required fields, if any)
mkUserUpdateInputEmail
  :: UserUpdateInputEmail
mkUserUpdateInputEmail =
  UserUpdateInputEmail
  { userUpdateInputEmailSet = Nothing
  }

-- ** UserUpdateInputName
-- | UserUpdateInputName
data UserUpdateInputName = UserUpdateInputName
  { userUpdateInputNameSet :: !(Maybe Text) -- ^ "set"
  , userUpdateInputNameUnset :: !(Maybe Bool) -- ^ "unset"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserUpdateInputName
instance A.FromJSON UserUpdateInputName where
  parseJSON = A.withObject "UserUpdateInputName" $ \o ->
    UserUpdateInputName
      <$> (o .:? "set")
      <*> (o .:? "unset")

-- | ToJSON UserUpdateInputName
instance A.ToJSON UserUpdateInputName where
  toJSON UserUpdateInputName {..} =
   _omitNulls
      [ "set" .= userUpdateInputNameSet
      , "unset" .= userUpdateInputNameUnset
      ]


-- | Construct a value of type 'UserUpdateInputName' (by applying it's required fields, if any)
mkUserUpdateInputName
  :: UserUpdateInputName
mkUserUpdateInputName =
  UserUpdateInputName
  { userUpdateInputNameSet = Nothing
  , userUpdateInputNameUnset = Nothing
  }

-- ** UserUpdateManyInput
-- | UserUpdateManyInput
data UserUpdateManyInput = UserUpdateManyInput
  { userUpdateManyInputEmail :: !(Maybe UserUpdateInputEmail) -- ^ "email"
  , userUpdateManyInputName :: !(Maybe UserUpdateInputName) -- ^ "name"
  , userUpdateManyInputPasswordhash :: !(Maybe UserUpdateInputEmail) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserUpdateManyInput
instance A.FromJSON UserUpdateManyInput where
  parseJSON = A.withObject "UserUpdateManyInput" $ \o ->
    UserUpdateManyInput
      <$> (o .:? "email")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserUpdateManyInput
instance A.ToJSON UserUpdateManyInput where
  toJSON UserUpdateManyInput {..} =
   _omitNulls
      [ "email" .= userUpdateManyInputEmail
      , "name" .= userUpdateManyInputName
      , "passwordhash" .= userUpdateManyInputPasswordhash
      ]


-- | Construct a value of type 'UserUpdateManyInput' (by applying it's required fields, if any)
mkUserUpdateManyInput
  :: UserUpdateManyInput
mkUserUpdateManyInput =
  UserUpdateManyInput
  { userUpdateManyInputEmail = Nothing
  , userUpdateManyInputName = Nothing
  , userUpdateManyInputPasswordhash = Nothing
  }

-- ** UserWhereInput
-- | UserWhereInput
data UserWhereInput = UserWhereInput
  { userWhereInputAnd :: !(Maybe UserWhereInputAND) -- ^ "AND"
  , userWhereInputNot :: !(Maybe UserWhereInputAND) -- ^ "NOT"
  , userWhereInputOr :: !(Maybe [UserWhereInput]) -- ^ "OR"
  , userWhereInputEmail :: !(Maybe UserWhereInputEmail) -- ^ "email"
  , userWhereInputId :: !(Maybe UserWhereInputEmail) -- ^ "id"
  , userWhereInputName :: !(Maybe UserWhereInputName) -- ^ "name"
  , userWhereInputPasswordhash :: !(Maybe UserWhereInputEmail) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserWhereInput
instance A.FromJSON UserWhereInput where
  parseJSON = A.withObject "UserWhereInput" $ \o ->
    UserWhereInput
      <$> (o .:? "AND")
      <*> (o .:? "NOT")
      <*> (o .:? "OR")
      <*> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserWhereInput
instance A.ToJSON UserWhereInput where
  toJSON UserWhereInput {..} =
   _omitNulls
      [ "AND" .= userWhereInputAnd
      , "NOT" .= userWhereInputNot
      , "OR" .= userWhereInputOr
      , "email" .= userWhereInputEmail
      , "id" .= userWhereInputId
      , "name" .= userWhereInputName
      , "passwordhash" .= userWhereInputPasswordhash
      ]


-- | Construct a value of type 'UserWhereInput' (by applying it's required fields, if any)
mkUserWhereInput
  :: UserWhereInput
mkUserWhereInput =
  UserWhereInput
  { userWhereInputAnd = Nothing
  , userWhereInputNot = Nothing
  , userWhereInputOr = Nothing
  , userWhereInputEmail = Nothing
  , userWhereInputId = Nothing
  , userWhereInputName = Nothing
  , userWhereInputPasswordhash = Nothing
  }

-- ** UserWhereInputAND
-- | UserWhereInputAND
data UserWhereInputAND = UserWhereInputAND
  { userWhereInputANDAnd :: !(Maybe UserWhereInputAND) -- ^ "AND"
  , userWhereInputANDNot :: !(Maybe UserWhereInputAND) -- ^ "NOT"
  , userWhereInputANDOr :: !(Maybe [UserWhereInput]) -- ^ "OR"
  , userWhereInputANDEmail :: !(Maybe UserWhereInputEmail) -- ^ "email"
  , userWhereInputANDId :: !(Maybe UserWhereInputEmail) -- ^ "id"
  , userWhereInputANDName :: !(Maybe UserWhereInputName) -- ^ "name"
  , userWhereInputANDPasswordhash :: !(Maybe UserWhereInputEmail) -- ^ "passwordhash"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserWhereInputAND
instance A.FromJSON UserWhereInputAND where
  parseJSON = A.withObject "UserWhereInputAND" $ \o ->
    UserWhereInputAND
      <$> (o .:? "AND")
      <*> (o .:? "NOT")
      <*> (o .:? "OR")
      <*> (o .:? "email")
      <*> (o .:? "id")
      <*> (o .:? "name")
      <*> (o .:? "passwordhash")

-- | ToJSON UserWhereInputAND
instance A.ToJSON UserWhereInputAND where
  toJSON UserWhereInputAND {..} =
   _omitNulls
      [ "AND" .= userWhereInputANDAnd
      , "NOT" .= userWhereInputANDNot
      , "OR" .= userWhereInputANDOr
      , "email" .= userWhereInputANDEmail
      , "id" .= userWhereInputANDId
      , "name" .= userWhereInputANDName
      , "passwordhash" .= userWhereInputANDPasswordhash
      ]


-- | Construct a value of type 'UserWhereInputAND' (by applying it's required fields, if any)
mkUserWhereInputAND
  :: UserWhereInputAND
mkUserWhereInputAND =
  UserWhereInputAND
  { userWhereInputANDAnd = Nothing
  , userWhereInputANDNot = Nothing
  , userWhereInputANDOr = Nothing
  , userWhereInputANDEmail = Nothing
  , userWhereInputANDId = Nothing
  , userWhereInputANDName = Nothing
  , userWhereInputANDPasswordhash = Nothing
  }

-- ** UserWhereInputEmail
-- | UserWhereInputEmail
data UserWhereInputEmail = UserWhereInputEmail
  { userWhereInputEmailContains :: !(Maybe Text) -- ^ "contains"
  , userWhereInputEmailEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , userWhereInputEmailEq :: !(Maybe Text) -- ^ "eq"
  , userWhereInputEmailEquals :: !(Maybe Text) -- ^ "equals"
  , userWhereInputEmailGt :: !(Maybe Text) -- ^ "gt"
  , userWhereInputEmailGte :: !(Maybe Text) -- ^ "gte"
  , userWhereInputEmailIn :: !(Maybe [Text]) -- ^ "in"
  , userWhereInputEmailLt :: !(Maybe Text) -- ^ "lt"
  , userWhereInputEmailLte :: !(Maybe Text) -- ^ "lte"
  , userWhereInputEmailMode :: !(Maybe QueryMode) -- ^ "mode"
  , userWhereInputEmailNot :: !(Maybe NestedStringFilterNot) -- ^ "not"
  , userWhereInputEmailNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , userWhereInputEmailStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserWhereInputEmail
instance A.FromJSON UserWhereInputEmail where
  parseJSON = A.withObject "UserWhereInputEmail" $ \o ->
    UserWhereInputEmail
      <$> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "mode")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON UserWhereInputEmail
instance A.ToJSON UserWhereInputEmail where
  toJSON UserWhereInputEmail {..} =
   _omitNulls
      [ "contains" .= userWhereInputEmailContains
      , "endsWith" .= userWhereInputEmailEndsWith
      , "eq" .= userWhereInputEmailEq
      , "equals" .= userWhereInputEmailEquals
      , "gt" .= userWhereInputEmailGt
      , "gte" .= userWhereInputEmailGte
      , "in" .= userWhereInputEmailIn
      , "lt" .= userWhereInputEmailLt
      , "lte" .= userWhereInputEmailLte
      , "mode" .= userWhereInputEmailMode
      , "not" .= userWhereInputEmailNot
      , "notIn" .= userWhereInputEmailNotIn
      , "startsWith" .= userWhereInputEmailStartsWith
      ]


-- | Construct a value of type 'UserWhereInputEmail' (by applying it's required fields, if any)
mkUserWhereInputEmail
  :: UserWhereInputEmail
mkUserWhereInputEmail =
  UserWhereInputEmail
  { userWhereInputEmailContains = Nothing
  , userWhereInputEmailEndsWith = Nothing
  , userWhereInputEmailEq = Nothing
  , userWhereInputEmailEquals = Nothing
  , userWhereInputEmailGt = Nothing
  , userWhereInputEmailGte = Nothing
  , userWhereInputEmailIn = Nothing
  , userWhereInputEmailLt = Nothing
  , userWhereInputEmailLte = Nothing
  , userWhereInputEmailMode = Nothing
  , userWhereInputEmailNot = Nothing
  , userWhereInputEmailNotIn = Nothing
  , userWhereInputEmailStartsWith = Nothing
  }

-- ** UserWhereInputName
-- | UserWhereInputName
data UserWhereInputName = UserWhereInputName
  { userWhereInputNameContains :: !(Maybe Text) -- ^ "contains"
  , userWhereInputNameEndsWith :: !(Maybe Text) -- ^ "endsWith"
  , userWhereInputNameEq :: !(Maybe Text) -- ^ "eq"
  , userWhereInputNameEquals :: !(Maybe Text) -- ^ "equals"
  , userWhereInputNameGt :: !(Maybe Text) -- ^ "gt"
  , userWhereInputNameGte :: !(Maybe Text) -- ^ "gte"
  , userWhereInputNameIn :: !(Maybe [Text]) -- ^ "in"
  , userWhereInputNameIsSet :: !(Maybe Bool) -- ^ "isSet"
  , userWhereInputNameLt :: !(Maybe Text) -- ^ "lt"
  , userWhereInputNameLte :: !(Maybe Text) -- ^ "lte"
  , userWhereInputNameMode :: !(Maybe QueryMode) -- ^ "mode"
  , userWhereInputNameNot :: !(Maybe NestedStringNullableFilterNot) -- ^ "not"
  , userWhereInputNameNotIn :: !(Maybe [Text]) -- ^ "notIn"
  , userWhereInputNameStartsWith :: !(Maybe Text) -- ^ "startsWith"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserWhereInputName
instance A.FromJSON UserWhereInputName where
  parseJSON = A.withObject "UserWhereInputName" $ \o ->
    UserWhereInputName
      <$> (o .:? "contains")
      <*> (o .:? "endsWith")
      <*> (o .:? "eq")
      <*> (o .:? "equals")
      <*> (o .:? "gt")
      <*> (o .:? "gte")
      <*> (o .:? "in")
      <*> (o .:? "isSet")
      <*> (o .:? "lt")
      <*> (o .:? "lte")
      <*> (o .:? "mode")
      <*> (o .:? "not")
      <*> (o .:? "notIn")
      <*> (o .:? "startsWith")

-- | ToJSON UserWhereInputName
instance A.ToJSON UserWhereInputName where
  toJSON UserWhereInputName {..} =
   _omitNulls
      [ "contains" .= userWhereInputNameContains
      , "endsWith" .= userWhereInputNameEndsWith
      , "eq" .= userWhereInputNameEq
      , "equals" .= userWhereInputNameEquals
      , "gt" .= userWhereInputNameGt
      , "gte" .= userWhereInputNameGte
      , "in" .= userWhereInputNameIn
      , "isSet" .= userWhereInputNameIsSet
      , "lt" .= userWhereInputNameLt
      , "lte" .= userWhereInputNameLte
      , "mode" .= userWhereInputNameMode
      , "not" .= userWhereInputNameNot
      , "notIn" .= userWhereInputNameNotIn
      , "startsWith" .= userWhereInputNameStartsWith
      ]


-- | Construct a value of type 'UserWhereInputName' (by applying it's required fields, if any)
mkUserWhereInputName
  :: UserWhereInputName
mkUserWhereInputName =
  UserWhereInputName
  { userWhereInputNameContains = Nothing
  , userWhereInputNameEndsWith = Nothing
  , userWhereInputNameEq = Nothing
  , userWhereInputNameEquals = Nothing
  , userWhereInputNameGt = Nothing
  , userWhereInputNameGte = Nothing
  , userWhereInputNameIn = Nothing
  , userWhereInputNameIsSet = Nothing
  , userWhereInputNameLt = Nothing
  , userWhereInputNameLte = Nothing
  , userWhereInputNameMode = Nothing
  , userWhereInputNameNot = Nothing
  , userWhereInputNameNotIn = Nothing
  , userWhereInputNameStartsWith = Nothing
  }

-- ** UserWhereUniqueInput
-- | UserWhereUniqueInput
data UserWhereUniqueInput = UserWhereUniqueInput
  { userWhereUniqueInputEmail :: !(Maybe Text) -- ^ "email"
  , userWhereUniqueInputId :: !(Maybe Text) -- ^ "id"
  } deriving (P.Show, P.Eq, P.Typeable)

-- | FromJSON UserWhereUniqueInput
instance A.FromJSON UserWhereUniqueInput where
  parseJSON = A.withObject "UserWhereUniqueInput" $ \o ->
    UserWhereUniqueInput
      <$> (o .:? "email")
      <*> (o .:? "id")

-- | ToJSON UserWhereUniqueInput
instance A.ToJSON UserWhereUniqueInput where
  toJSON UserWhereUniqueInput {..} =
   _omitNulls
      [ "email" .= userWhereUniqueInputEmail
      , "id" .= userWhereUniqueInputId
      ]


-- | Construct a value of type 'UserWhereUniqueInput' (by applying it's required fields, if any)
mkUserWhereUniqueInput
  :: UserWhereUniqueInput
mkUserWhereUniqueInput =
  UserWhereUniqueInput
  { userWhereUniqueInputEmail = Nothing
  , userWhereUniqueInputId = Nothing
  }


-- * Enums


-- ** E'Count

-- | Enum of 'Text'
data E'Count
  = E'Count'_all -- ^ @"_all"@
  | E'Count'Email -- ^ @"email"@
  | E'Count'Id -- ^ @"id"@
  | E'Count'Name -- ^ @"name"@
  | E'Count'Passwordhash -- ^ @"passwordhash"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Count where toJSON = A.toJSON . fromE'Count
instance A.FromJSON E'Count where parseJSON o = P.either P.fail (pure . P.id) . toE'Count =<< A.parseJSON o
instance WH.ToHttpApiData E'Count where toQueryParam = WH.toQueryParam . fromE'Count
instance WH.FromHttpApiData E'Count where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Count
instance MimeRender MimeMultipartFormData E'Count where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Count' enum
fromE'Count :: E'Count -> Text
fromE'Count = \case
  E'Count'_all -> "_all"
  E'Count'Email -> "email"
  E'Count'Id -> "id"
  E'Count'Name -> "name"
  E'Count'Passwordhash -> "passwordhash"

-- | parse 'E'Count' enum
toE'Count :: Text -> P.Either String E'Count
toE'Count = \case
  "_all" -> P.Right E'Count'_all
  "email" -> P.Right E'Count'Email
  "id" -> P.Right E'Count'Id
  "name" -> P.Right E'Count'Name
  "passwordhash" -> P.Right E'Count'Passwordhash
  s -> P.Left $ "toE'Count: enum parse failure: " P.++ P.show s


-- ** E'Max

-- | Enum of 'Text'
data E'Max
  = E'Max'Email -- ^ @"email"@
  | E'Max'Id -- ^ @"id"@
  | E'Max'Name -- ^ @"name"@
  | E'Max'Passwordhash -- ^ @"passwordhash"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON E'Max where toJSON = A.toJSON . fromE'Max
instance A.FromJSON E'Max where parseJSON o = P.either P.fail (pure . P.id) . toE'Max =<< A.parseJSON o
instance WH.ToHttpApiData E'Max where toQueryParam = WH.toQueryParam . fromE'Max
instance WH.FromHttpApiData E'Max where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toE'Max
instance MimeRender MimeMultipartFormData E'Max where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'E'Max' enum
fromE'Max :: E'Max -> Text
fromE'Max = \case
  E'Max'Email -> "email"
  E'Max'Id -> "id"
  E'Max'Name -> "name"
  E'Max'Passwordhash -> "passwordhash"

-- | parse 'E'Max' enum
toE'Max :: Text -> P.Either String E'Max
toE'Max = \case
  "email" -> P.Right E'Max'Email
  "id" -> P.Right E'Max'Id
  "name" -> P.Right E'Max'Name
  "passwordhash" -> P.Right E'Max'Passwordhash
  s -> P.Left $ "toE'Max: enum parse failure: " P.++ P.show s


-- ** QueryMode

-- | Enum of 'Text'
data QueryMode
  = QueryMode'Default -- ^ @"default"@
  | QueryMode'Insensitive -- ^ @"insensitive"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON QueryMode where toJSON = A.toJSON . fromQueryMode
instance A.FromJSON QueryMode where parseJSON o = P.either P.fail (pure . P.id) . toQueryMode =<< A.parseJSON o
instance WH.ToHttpApiData QueryMode where toQueryParam = WH.toQueryParam . fromQueryMode
instance WH.FromHttpApiData QueryMode where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toQueryMode
instance MimeRender MimeMultipartFormData QueryMode where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'QueryMode' enum
fromQueryMode :: QueryMode -> Text
fromQueryMode = \case
  QueryMode'Default -> "default"
  QueryMode'Insensitive -> "insensitive"

-- | parse 'QueryMode' enum
toQueryMode :: Text -> P.Either String QueryMode
toQueryMode = \case
  "default" -> P.Right QueryMode'Default
  "insensitive" -> P.Right QueryMode'Insensitive
  s -> P.Left $ "toQueryMode: enum parse failure: " P.++ P.show s


-- ** SortOrder

-- | Enum of 'Text'
data SortOrder
  = SortOrder'Asc -- ^ @"asc"@
  | SortOrder'Desc -- ^ @"desc"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON SortOrder where toJSON = A.toJSON . fromSortOrder
instance A.FromJSON SortOrder where parseJSON o = P.either P.fail (pure . P.id) . toSortOrder =<< A.parseJSON o
instance WH.ToHttpApiData SortOrder where toQueryParam = WH.toQueryParam . fromSortOrder
instance WH.FromHttpApiData SortOrder where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toSortOrder
instance MimeRender MimeMultipartFormData SortOrder where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'SortOrder' enum
fromSortOrder :: SortOrder -> Text
fromSortOrder = \case
  SortOrder'Asc -> "asc"
  SortOrder'Desc -> "desc"

-- | parse 'SortOrder' enum
toSortOrder :: Text -> P.Either String SortOrder
toSortOrder = \case
  "asc" -> P.Right SortOrder'Asc
  "desc" -> P.Right SortOrder'Desc
  s -> P.Left $ "toSortOrder: enum parse failure: " P.++ P.show s


-- ** UserScalarFieldEnum

-- | Enum of 'Text'
data UserScalarFieldEnum
  = UserScalarFieldEnum'Email -- ^ @"email"@
  | UserScalarFieldEnum'Id -- ^ @"id"@
  | UserScalarFieldEnum'Name -- ^ @"name"@
  | UserScalarFieldEnum'Passwordhash -- ^ @"passwordhash"@
  deriving (P.Show, P.Eq, P.Typeable, P.Ord, P.Bounded, P.Enum)

instance A.ToJSON UserScalarFieldEnum where toJSON = A.toJSON . fromUserScalarFieldEnum
instance A.FromJSON UserScalarFieldEnum where parseJSON o = P.either P.fail (pure . P.id) . toUserScalarFieldEnum =<< A.parseJSON o
instance WH.ToHttpApiData UserScalarFieldEnum where toQueryParam = WH.toQueryParam . fromUserScalarFieldEnum
instance WH.FromHttpApiData UserScalarFieldEnum where parseQueryParam o = WH.parseQueryParam o >>= P.left T.pack . toUserScalarFieldEnum
instance MimeRender MimeMultipartFormData UserScalarFieldEnum where mimeRender _ = mimeRenderDefaultMultipartFormData

-- | unwrap 'UserScalarFieldEnum' enum
fromUserScalarFieldEnum :: UserScalarFieldEnum -> Text
fromUserScalarFieldEnum = \case
  UserScalarFieldEnum'Email -> "email"
  UserScalarFieldEnum'Id -> "id"
  UserScalarFieldEnum'Name -> "name"
  UserScalarFieldEnum'Passwordhash -> "passwordhash"

-- | parse 'UserScalarFieldEnum' enum
toUserScalarFieldEnum :: Text -> P.Either String UserScalarFieldEnum
toUserScalarFieldEnum = \case
  "email" -> P.Right UserScalarFieldEnum'Email
  "id" -> P.Right UserScalarFieldEnum'Id
  "name" -> P.Right UserScalarFieldEnum'Name
  "passwordhash" -> P.Right UserScalarFieldEnum'Passwordhash
  s -> P.Left $ "toUserScalarFieldEnum: enum parse failure: " P.++ P.show s


-- * Auth Methods

-- ** AuthApiKeyApiKey
data AuthApiKeyApiKey =
  AuthApiKeyApiKey Text -- ^ secret
  deriving (P.Eq, P.Show, P.Typeable)

instance AuthMethod AuthApiKeyApiKey where
  applyAuthMethod _ a@(AuthApiKeyApiKey secret) req =
    P.pure $
    if (P.typeOf a `P.elem` rAuthTypes req)
      then req `setHeader` toHeader ("X-API-KEY", secret)
           & L.over rAuthTypesL (P.filter (/= P.typeOf a))
      else req


